{"ast":null,"code":"'use strict';\n\nvar React = require('react');\nvar PdfJsApi = require('pdfjs-dist');\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);\nvar PdfJsApi__namespace = /*#__PURE__*/_interopNamespaceDefault(PdfJsApi);\nexports.AnnotationType = void 0;\n(function (AnnotationType) {\n  AnnotationType[AnnotationType[\"Text\"] = 1] = \"Text\";\n  AnnotationType[AnnotationType[\"Link\"] = 2] = \"Link\";\n  AnnotationType[AnnotationType[\"FreeText\"] = 3] = \"FreeText\";\n  AnnotationType[AnnotationType[\"Line\"] = 4] = \"Line\";\n  AnnotationType[AnnotationType[\"Square\"] = 5] = \"Square\";\n  AnnotationType[AnnotationType[\"Circle\"] = 6] = \"Circle\";\n  AnnotationType[AnnotationType[\"Polygon\"] = 7] = \"Polygon\";\n  AnnotationType[AnnotationType[\"Polyline\"] = 8] = \"Polyline\";\n  AnnotationType[AnnotationType[\"Highlight\"] = 9] = \"Highlight\";\n  AnnotationType[AnnotationType[\"Underline\"] = 10] = \"Underline\";\n  AnnotationType[AnnotationType[\"Squiggly\"] = 11] = \"Squiggly\";\n  AnnotationType[AnnotationType[\"StrikeOut\"] = 12] = \"StrikeOut\";\n  AnnotationType[AnnotationType[\"Stamp\"] = 13] = \"Stamp\";\n  AnnotationType[AnnotationType[\"Caret\"] = 14] = \"Caret\";\n  AnnotationType[AnnotationType[\"Ink\"] = 15] = \"Ink\";\n  AnnotationType[AnnotationType[\"Popup\"] = 16] = \"Popup\";\n  AnnotationType[AnnotationType[\"FileAttachment\"] = 17] = \"FileAttachment\";\n})(exports.AnnotationType || (exports.AnnotationType = {}));\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\nexports.TextDirection = void 0;\n(function (TextDirection) {\n  TextDirection[\"RightToLeft\"] = \"RTL\";\n  TextDirection[\"LeftToRight\"] = \"LTR\";\n})(exports.TextDirection || (exports.TextDirection = {}));\nvar ThemeContext = React__namespace.createContext({\n  currentTheme: 'light',\n  direction: exports.TextDirection.LeftToRight,\n  setCurrentTheme: function () {}\n});\nvar classNames = function (classes) {\n  var result = [];\n  Object.keys(classes).forEach(function (clazz) {\n    if (clazz && classes[clazz]) {\n      result.push(clazz);\n    }\n  });\n  return result.join(' ');\n};\nvar Button = function (_a) {\n  var children = _a.children,\n    testId = _a.testId,\n    onClick = _a.onClick;\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  var attrs = testId ? {\n    'data-testid': testId\n  } : {};\n  return React__namespace.createElement(\"button\", __assign({\n    className: classNames({\n      'rpv-core__button': true,\n      'rpv-core__button--rtl': isRtl\n    }),\n    type: \"button\",\n    onClick: onClick\n  }, attrs), children);\n};\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;\nvar useIntersectionObserver = function (props) {\n  var containerRef = React__namespace.useRef(null);\n  var once = props.once,\n    threshold = props.threshold,\n    onVisibilityChanged = props.onVisibilityChanged;\n  useIsomorphicLayoutEffect(function () {\n    var container = containerRef.current;\n    if (!container) {\n      return;\n    }\n    var intersectionTracker = new IntersectionObserver(function (entries) {\n      entries.forEach(function (entry) {\n        var isVisible = entry.isIntersecting;\n        var ratio = entry.intersectionRatio;\n        onVisibilityChanged({\n          isVisible: isVisible,\n          ratio: ratio\n        });\n        if (isVisible && once) {\n          intersectionTracker.unobserve(container);\n          intersectionTracker.disconnect();\n        }\n      });\n    }, {\n      threshold: threshold || 0\n    });\n    intersectionTracker.observe(container);\n    return function () {\n      intersectionTracker.unobserve(container);\n      intersectionTracker.disconnect();\n    };\n  }, []);\n  return containerRef;\n};\nvar LazyRender = function (_a) {\n  var attrs = _a.attrs,\n    children = _a.children,\n    testId = _a.testId;\n  var _b = React__namespace.useState(false),\n    visible = _b[0],\n    setVisible = _b[1];\n  var containerAttrs = testId ? __assign(__assign({}, attrs), {\n    'data-testid': testId\n  }) : attrs;\n  var handleVisibilityChanged = function (params) {\n    if (params.isVisible) {\n      setVisible(true);\n    }\n  };\n  var containerRef = useIntersectionObserver({\n    once: true,\n    onVisibilityChanged: handleVisibilityChanged\n  });\n  return React__namespace.createElement(\"div\", __assign({\n    ref: containerRef\n  }, containerAttrs), visible && children);\n};\nvar Menu = function (_a) {\n  var children = _a.children;\n  var containerRef = React__namespace.useRef();\n  var visibleMenuItemsRef = React__namespace.useRef([]);\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  var handleKeyDown = function (e) {\n    var container = containerRef.current;\n    if (!container) {\n      return;\n    }\n    switch (e.key) {\n      case 'Tab':\n        e.preventDefault();\n        break;\n      case 'ArrowDown':\n        e.preventDefault();\n        moveToItem(function (_, currentIndex) {\n          return currentIndex + 1;\n        });\n        break;\n      case 'ArrowUp':\n        e.preventDefault();\n        moveToItem(function (_, currentIndex) {\n          return currentIndex - 1;\n        });\n        break;\n      case 'End':\n        e.preventDefault();\n        moveToItem(function (items, _) {\n          return items.length - 1;\n        });\n        break;\n      case 'Home':\n        e.preventDefault();\n        moveToItem(function (_, __) {\n          return 0;\n        });\n        break;\n    }\n  };\n  var moveToItem = function (getNextItem) {\n    var container = containerRef.current;\n    if (!container) {\n      return;\n    }\n    var items = visibleMenuItemsRef.current;\n    var currentIndex = items.findIndex(function (item) {\n      return item.getAttribute('tabindex') === '0';\n    });\n    var targetIndex = Math.min(items.length - 1, Math.max(0, getNextItem(items, currentIndex)));\n    if (currentIndex >= 0 && currentIndex <= items.length - 1) {\n      items[currentIndex].setAttribute('tabindex', '-1');\n    }\n    items[targetIndex].setAttribute('tabindex', '0');\n    items[targetIndex].focus();\n  };\n  var findVisibleItems = function (container) {\n    var visibleItems = [];\n    container.querySelectorAll('.rpv-core__menu-item[role=\"menuitem\"]').forEach(function (item) {\n      if (item instanceof HTMLElement) {\n        var parent_1 = item.parentElement;\n        if (parent_1 === container) {\n          visibleItems.push(item);\n        } else {\n          if (window.getComputedStyle(parent_1).display !== 'none') {\n            visibleItems.push(item);\n          }\n        }\n      }\n    });\n    return visibleItems;\n  };\n  useIsomorphicLayoutEffect(function () {\n    var container = containerRef.current;\n    if (!container) {\n      return;\n    }\n    var visibleItems = findVisibleItems(container);\n    visibleMenuItemsRef.current = visibleItems;\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    document.addEventListener('keydown', handleKeyDown);\n    return function () {\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    ref: containerRef,\n    \"aria-orientation\": \"vertical\",\n    className: classNames({\n      'rpv-core__menu': true,\n      'rpv-core__menu--rtl': isRtl\n    }),\n    role: \"menu\",\n    tabIndex: 0\n  }, children);\n};\nvar MenuDivider = function () {\n  return React__namespace.createElement(\"div\", {\n    \"aria-orientation\": \"horizontal\",\n    className: \"rpv-core__menu-divider\",\n    role: \"separator\"\n  });\n};\nvar Icon = function (_a) {\n  var children = _a.children,\n    _b = _a.ignoreDirection,\n    ignoreDirection = _b === void 0 ? false : _b,\n    _c = _a.size,\n    size = _c === void 0 ? 24 : _c;\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = !ignoreDirection && direction === exports.TextDirection.RightToLeft;\n  var width = \"\".concat(size || 24, \"px\");\n  return React__namespace.createElement(\"svg\", {\n    \"aria-hidden\": \"true\",\n    className: classNames({\n      'rpv-core__icon': true,\n      'rpv-core__icon--rtl': isRtl\n    }),\n    focusable: \"false\",\n    height: width,\n    viewBox: \"0 0 24 24\",\n    width: width\n  }, children);\n};\nvar CheckIcon = function () {\n  return React__namespace.createElement(Icon, {\n    size: 16\n  }, React__namespace.createElement(\"path\", {\n    d: \"M23.5,0.499l-16.5,23l-6.5-6.5\"\n  }));\n};\nvar MenuItem = function (_a) {\n  var _b = _a.checked,\n    checked = _b === void 0 ? false : _b,\n    children = _a.children,\n    _c = _a.icon,\n    icon = _c === void 0 ? null : _c,\n    _d = _a.isDisabled,\n    isDisabled = _d === void 0 ? false : _d,\n    testId = _a.testId,\n    onClick = _a.onClick;\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  var attrs = testId ? {\n    'data-testid': testId\n  } : {};\n  return React__namespace.createElement(\"button\", __assign({\n    className: classNames({\n      'rpv-core__menu-item': true,\n      'rpv-core__menu-item--disabled': isDisabled,\n      'rpv-core__menu-item--ltr': !isRtl,\n      'rpv-core__menu-item--rtl': isRtl\n    }),\n    role: \"menuitem\",\n    tabIndex: -1,\n    type: \"button\",\n    onClick: onClick\n  }, attrs), React__namespace.createElement(\"div\", {\n    className: classNames({\n      'rpv-core__menu-item-icon': true,\n      'rpv-core__menu-item-icon--ltr': !isRtl,\n      'rpv-core__menu-item-icon--rtl': isRtl\n    })\n  }, icon), React__namespace.createElement(\"div\", {\n    className: classNames({\n      'rpv-core__menu-item-label': true,\n      'rpv-core__menu-item-label--ltr': !isRtl,\n      'rpv-core__menu-item-label--rtl': isRtl\n    })\n  }, children), React__namespace.createElement(\"div\", {\n    className: classNames({\n      'rpv-core__menu-item-check': true,\n      'rpv-core__menu-item-check--ltr': !isRtl,\n      'rpv-core__menu-item-check--rtl': isRtl\n    })\n  }, checked && React__namespace.createElement(CheckIcon, null)));\n};\nvar MinimalButton = function (_a) {\n  var _b = _a.ariaLabel,\n    ariaLabel = _b === void 0 ? '' : _b,\n    _c = _a.ariaKeyShortcuts,\n    ariaKeyShortcuts = _c === void 0 ? '' : _c,\n    children = _a.children,\n    _d = _a.isDisabled,\n    isDisabled = _d === void 0 ? false : _d,\n    _e = _a.isSelected,\n    isSelected = _e === void 0 ? false : _e,\n    testId = _a.testId,\n    onClick = _a.onClick;\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  var attrs = testId ? {\n    'data-testid': testId\n  } : {};\n  return React__namespace.createElement(\"button\", __assign({\n    \"aria-label\": ariaLabel\n  }, ariaKeyShortcuts && {\n    'aria-keyshortcuts': ariaKeyShortcuts\n  }, isDisabled && {\n    'aria-disabled': true\n  }, {\n    className: classNames({\n      'rpv-core__minimal-button': true,\n      'rpv-core__minimal-button--disabled': isDisabled,\n      'rpv-core__minimal-button--rtl': isRtl,\n      'rpv-core__minimal-button--selected': isSelected\n    }),\n    type: \"button\",\n    onClick: onClick\n  }, attrs), children);\n};\nvar PrimaryButton = function (_a) {\n  var children = _a.children,\n    testId = _a.testId,\n    onClick = _a.onClick;\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  var attrs = testId ? {\n    'data-testid': testId\n  } : {};\n  return React__namespace.createElement(\"button\", __assign({\n    className: classNames({\n      'rpv-core__primary-button': true,\n      'rpv-core__primary-button--rtl': isRtl\n    }),\n    type: \"button\",\n    onClick: onClick\n  }, attrs), children);\n};\nvar ProgressBar = function (_a) {\n  var progress = _a.progress;\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  return React__namespace.createElement(\"div\", {\n    className: classNames({\n      'rpv-core__progress-bar': true,\n      'rpv-core__progress-bar--rtl': isRtl\n    })\n  }, React__namespace.createElement(\"div\", {\n    className: \"rpv-core__progress-bar-progress\",\n    style: {\n      width: \"\".concat(progress, \"%\")\n    }\n  }, progress, \"%\"));\n};\nvar Separator = function () {\n  return React__namespace.createElement(\"div\", {\n    className: \"rpv-core__separator\"\n  });\n};\nvar Spinner = function (_a) {\n  var _b = _a.size,\n    size = _b === void 0 ? '4rem' : _b,\n    testId = _a.testId;\n  var _c = React__namespace.useState(false),\n    visible = _c[0],\n    setVisible = _c[1];\n  var attrs = testId ? {\n    'data-testid': testId\n  } : {};\n  var handleVisibilityChanged = function (params) {\n    setVisible(params.isVisible);\n  };\n  var containerRef = useIntersectionObserver({\n    onVisibilityChanged: handleVisibilityChanged\n  });\n  return React__namespace.createElement(\"div\", __assign({}, attrs, {\n    className: classNames({\n      'rpv-core__spinner': true,\n      'rpv-core__spinner--animating': visible\n    }),\n    ref: containerRef,\n    style: {\n      height: size,\n      width: size\n    }\n  }));\n};\nvar Splitter = function (_a) {\n  var constrain = _a.constrain;\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  var resizerRef = React__namespace.useRef();\n  var leftSideRef = React__namespace.useRef();\n  var rightSideRef = React__namespace.useRef();\n  var xRef = React__namespace.useRef(0);\n  var yRef = React__namespace.useRef(0);\n  var leftWidthRef = React__namespace.useRef(0);\n  var resizerWidthRef = React__namespace.useRef(0);\n  var eventOptions = {\n    capture: true\n  };\n  var handleMouseMove = function (e) {\n    var resizerEle = resizerRef.current;\n    var leftSide = leftSideRef.current;\n    var rightSide = rightSideRef.current;\n    if (!resizerEle || !leftSide || !rightSide) {\n      return;\n    }\n    var resizerWidth = resizerWidthRef.current;\n    var dx = e.clientX - xRef.current;\n    var firstHalfSize = leftWidthRef.current + (isRtl ? -dx : dx);\n    var containerWidth = resizerEle.parentElement.getBoundingClientRect().width;\n    var firstHalfPercentage = firstHalfSize * 100 / containerWidth;\n    resizerEle.classList.add('rpv-core__splitter--resizing');\n    if (constrain) {\n      var secondHalfSize = containerWidth - firstHalfSize - resizerWidth;\n      var secondHalfPercentage = secondHalfSize * 100 / containerWidth;\n      if (!constrain({\n        firstHalfPercentage: firstHalfPercentage,\n        firstHalfSize: firstHalfSize,\n        secondHalfPercentage: secondHalfPercentage,\n        secondHalfSize: secondHalfSize\n      })) {\n        return;\n      }\n    }\n    leftSide.style.width = \"\".concat(firstHalfPercentage, \"%\");\n    document.body.classList.add('rpv-core__splitter-body--resizing');\n    leftSide.classList.add('rpv-core__splitter-sibling--resizing');\n    rightSide.classList.add('rpv-core__splitter-sibling--resizing');\n  };\n  var handleMouseUp = function (e) {\n    var resizerEle = resizerRef.current;\n    var leftSide = leftSideRef.current;\n    var rightSide = rightSideRef.current;\n    if (!resizerEle || !leftSide || !rightSide) {\n      return;\n    }\n    document.body.classList.remove('rpv-core__splitter-body--resizing');\n    resizerEle.classList.remove('rpv-core__splitter--resizing');\n    leftSide.classList.remove('rpv-core__splitter-sibling--resizing');\n    rightSide.classList.remove('rpv-core__splitter-sibling--resizing');\n    document.removeEventListener('mousemove', handleMouseMove, eventOptions);\n    document.removeEventListener('mouseup', handleMouseUp, eventOptions);\n  };\n  var handleMouseDown = function (e) {\n    var leftSide = leftSideRef.current;\n    if (!leftSide) {\n      return;\n    }\n    xRef.current = e.clientX;\n    yRef.current = e.clientY;\n    leftWidthRef.current = leftSide.getBoundingClientRect().width;\n    document.addEventListener('mousemove', handleMouseMove, eventOptions);\n    document.addEventListener('mouseup', handleMouseUp, eventOptions);\n  };\n  React__namespace.useEffect(function () {\n    var resizerEle = resizerRef.current;\n    if (!resizerEle) {\n      return;\n    }\n    resizerWidthRef.current = resizerEle.getBoundingClientRect().width;\n    leftSideRef.current = resizerEle.previousElementSibling;\n    rightSideRef.current = resizerEle.nextElementSibling;\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    ref: resizerRef,\n    className: \"rpv-core__splitter\",\n    onMouseDown: handleMouseDown\n  });\n};\nvar TextBox = function (_a) {\n  var _b = _a.ariaLabel,\n    ariaLabel = _b === void 0 ? '' : _b,\n    _c = _a.autoFocus,\n    autoFocus = _c === void 0 ? false : _c,\n    _d = _a.placeholder,\n    placeholder = _d === void 0 ? '' : _d,\n    testId = _a.testId,\n    _e = _a.type,\n    type = _e === void 0 ? 'text' : _e,\n    _f = _a.value,\n    value = _f === void 0 ? '' : _f,\n    onChange = _a.onChange,\n    _g = _a.onKeyDown,\n    onKeyDown = _g === void 0 ? function () {} : _g;\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var textboxRef = React__namespace.useRef();\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  var attrs = {\n    ref: textboxRef,\n    'data-testid': '',\n    'aria-label': ariaLabel,\n    className: classNames({\n      'rpv-core__textbox': true,\n      'rpv-core__textbox--rtl': isRtl\n    }),\n    placeholder: placeholder,\n    value: value,\n    onChange: function (e) {\n      return onChange(e.target.value);\n    },\n    onKeyDown: onKeyDown\n  };\n  if (testId) {\n    attrs['data-testid'] = testId;\n  }\n  useIsomorphicLayoutEffect(function () {\n    if (autoFocus) {\n      var textboxEle = textboxRef.current;\n      if (textboxEle) {\n        var x = window.scrollX;\n        var y = window.scrollY;\n        textboxEle.focus();\n        window.scrollTo(x, y);\n      }\n    }\n  }, []);\n  return type === 'text' ? React__namespace.createElement(\"input\", __assign({\n    type: \"text\"\n  }, attrs)) : React__namespace.createElement(\"input\", __assign({\n    type: \"password\"\n  }, attrs));\n};\nvar Api;\n(function (Api) {\n  Api[Api[\"ExitFullScreen\"] = 0] = \"ExitFullScreen\";\n  Api[Api[\"FullScreenChange\"] = 1] = \"FullScreenChange\";\n  Api[Api[\"FullScreenElement\"] = 2] = \"FullScreenElement\";\n  Api[Api[\"FullScreenEnabled\"] = 3] = \"FullScreenEnabled\";\n  Api[Api[\"RequestFullScreen\"] = 4] = \"RequestFullScreen\";\n})(Api || (Api = {}));\nvar defaultVendor = {\n  ExitFullScreen: 'exitFullscreen',\n  FullScreenChange: 'fullscreenchange',\n  FullScreenElement: 'fullscreenElement',\n  FullScreenEnabled: 'fullscreenEnabled',\n  RequestFullScreen: 'requestFullscreen'\n};\nvar webkitVendor = {\n  ExitFullScreen: 'webkitExitFullscreen',\n  FullScreenChange: 'webkitfullscreenchange',\n  FullScreenElement: 'webkitFullscreenElement',\n  FullScreenEnabled: 'webkitFullscreenEnabled',\n  RequestFullScreen: 'webkitRequestFullscreen'\n};\nvar msVendor = {\n  ExitFullScreen: 'msExitFullscreen',\n  FullScreenChange: 'msFullscreenChange',\n  FullScreenElement: 'msFullscreenElement',\n  FullScreenEnabled: 'msFullscreenEnabled',\n  RequestFullScreen: 'msRequestFullscreen'\n};\nvar isBrowser = typeof window !== 'undefined';\nvar vendor = isBrowser ? Api.FullScreenEnabled in document && defaultVendor || webkitVendor.FullScreenEnabled in document && webkitVendor || msVendor.FullScreenEnabled in document && msVendor || defaultVendor : defaultVendor;\nvar isFullScreenEnabled = function () {\n  return isBrowser && vendor.FullScreenEnabled in document && document[vendor.FullScreenEnabled] === true;\n};\nvar addFullScreenChangeListener = function (handler) {\n  if (isBrowser) {\n    document.addEventListener(vendor.FullScreenChange, handler);\n  }\n};\nvar removeFullScreenChangeListener = function (handler) {\n  if (isBrowser) {\n    document.removeEventListener(vendor.FullScreenChange, handler);\n  }\n};\nvar exitFullScreen = function (element) {\n  return isBrowser ? element[vendor.ExitFullScreen]() : Promise.resolve({});\n};\nvar getFullScreenElement = function () {\n  return isBrowser ? document[vendor.FullScreenElement] : null;\n};\nvar requestFullScreen = function (element) {\n  if (isBrowser) {\n    element[vendor.RequestFullScreen]();\n  }\n};\nvar useDebounceCallback = function (callback, wait) {\n  var timeout = React__namespace.useRef();\n  var cleanup = function () {\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n    }\n  };\n  React__namespace.useEffect(function () {\n    return function () {\n      return cleanup();\n    };\n  }, []);\n  return React__namespace.useCallback(function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    cleanup();\n    timeout.current = setTimeout(function () {\n      callback.apply(void 0, args);\n    }, wait);\n  }, [callback, wait]);\n};\nvar useIsMounted = function () {\n  var isMountedRef = React__namespace.useRef(false);\n  React__namespace.useEffect(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef;\n};\nvar usePrevious = function (value) {\n  var ref = React__namespace.useRef(value);\n  React__namespace.useEffect(function () {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n};\nvar PageRenderStatus;\n(function (PageRenderStatus) {\n  PageRenderStatus[\"NotRenderedYet\"] = \"NotRenderedYet\";\n  PageRenderStatus[\"Rendering\"] = \"Rendering\";\n  PageRenderStatus[\"Rendered\"] = \"Rendered\";\n})(PageRenderStatus || (PageRenderStatus = {}));\nvar OUT_OF_RANGE_VISIBILITY = -9999;\nvar useRenderQueue = function (_a) {\n  var doc = _a.doc;\n  var numPages = doc.numPages;\n  var docId = doc.loadingTask.docId;\n  var initialPageVisibilities = React__namespace.useMemo(function () {\n    return Array(numPages).fill(null).map(function (_, pageIndex) {\n      return {\n        pageIndex: pageIndex,\n        renderStatus: PageRenderStatus.NotRenderedYet,\n        visibility: OUT_OF_RANGE_VISIBILITY\n      };\n    });\n  }, [docId]);\n  var latestRef = React__namespace.useRef({\n    currentRenderingPage: -1,\n    startRange: 0,\n    endRange: numPages - 1,\n    visibilities: initialPageVisibilities\n  });\n  var markNotRendered = function () {\n    for (var i = 0; i < numPages; i++) {\n      latestRef.current.visibilities[i].renderStatus = PageRenderStatus.NotRenderedYet;\n    }\n  };\n  var markRendered = function (pageIndex) {\n    latestRef.current.visibilities[pageIndex].renderStatus = PageRenderStatus.Rendered;\n  };\n  var markRendering = function (pageIndex) {\n    if (latestRef.current.currentRenderingPage !== -1 && latestRef.current.currentRenderingPage !== pageIndex && latestRef.current.visibilities[latestRef.current.currentRenderingPage].renderStatus === PageRenderStatus.Rendering) {\n      latestRef.current.visibilities[latestRef.current.currentRenderingPage].renderStatus = PageRenderStatus.NotRenderedYet;\n    }\n    latestRef.current.visibilities[pageIndex].renderStatus = PageRenderStatus.Rendering;\n    latestRef.current.currentRenderingPage = pageIndex;\n  };\n  var setRange = function (startIndex, endIndex) {\n    latestRef.current.startRange = startIndex;\n    latestRef.current.endRange = endIndex;\n    for (var i = 0; i < numPages; i++) {\n      if (i < startIndex || i > endIndex) {\n        latestRef.current.visibilities[i].visibility = OUT_OF_RANGE_VISIBILITY;\n        latestRef.current.visibilities[i].renderStatus = PageRenderStatus.NotRenderedYet;\n      }\n    }\n  };\n  var setOutOfRange = function (pageIndex) {\n    setVisibility(pageIndex, OUT_OF_RANGE_VISIBILITY);\n  };\n  var setVisibility = function (pageIndex, visibility) {\n    latestRef.current.visibilities[pageIndex].visibility = visibility;\n  };\n  var getHighestPriorityPage = function () {\n    var visiblePages = latestRef.current.visibilities.slice(latestRef.current.startRange, latestRef.current.endRange + 1).filter(function (item) {\n      return item.visibility > OUT_OF_RANGE_VISIBILITY;\n    });\n    if (!visiblePages.length) {\n      return -1;\n    }\n    var firstVisiblePage = visiblePages[0].pageIndex;\n    var lastVisiblePage = visiblePages[visiblePages.length - 1].pageIndex;\n    var numVisiblePages = visiblePages.length;\n    for (var i = 0; i < numVisiblePages; i++) {\n      if (visiblePages[i].renderStatus === PageRenderStatus.Rendering) {\n        return -1;\n      }\n      if (visiblePages[i].renderStatus === PageRenderStatus.NotRenderedYet) {\n        return visiblePages[i].pageIndex;\n      }\n    }\n    if (lastVisiblePage + 1 < numPages && latestRef.current.visibilities[lastVisiblePage + 1].renderStatus !== PageRenderStatus.Rendered) {\n      return lastVisiblePage + 1;\n    } else if (firstVisiblePage - 1 >= 0 && latestRef.current.visibilities[firstVisiblePage - 1].renderStatus !== PageRenderStatus.Rendered) {\n      return firstVisiblePage - 1;\n    }\n    return -1;\n  };\n  var isInRange = function (pageIndex) {\n    return pageIndex >= latestRef.current.startRange && pageIndex <= latestRef.current.endRange;\n  };\n  return {\n    getHighestPriorityPage: getHighestPriorityPage,\n    isInRange: isInRange,\n    markNotRendered: markNotRendered,\n    markRendered: markRendered,\n    markRendering: markRendering,\n    setOutOfRange: setOutOfRange,\n    setRange: setRange,\n    setVisibility: setVisibility\n  };\n};\nvar core = {\n  askingPassword: {\n    requirePasswordToOpen: \"This document requires a password to open\",\n    submit: \"Submit\"\n  },\n  wrongPassword: {\n    tryAgain: \"The password is wrong. Please try again\"\n  },\n  pageLabel: \"Page {{pageIndex}}\"\n};\nvar enUs = {\n  core: core\n};\nvar DefaultLocalization = enUs;\nvar LocalizationContext = React__namespace.createContext({\n  l10n: DefaultLocalization,\n  setL10n: function () {}\n});\nvar id = 0;\nvar uniqueId = function () {\n  return id++;\n};\nvar useClickOutside = function (closeOnClickOutside, targetRef, onClickOutside) {\n  var clickHandler = function (e) {\n    var target = targetRef.current;\n    if (!target) {\n      return;\n    }\n    var clickedTarget = e.target;\n    if (clickedTarget instanceof Element && clickedTarget.shadowRoot) {\n      var paths = e.composedPath();\n      if (paths.length > 0 && !target.contains(paths[0])) {\n        onClickOutside();\n      }\n    } else if (!target.contains(clickedTarget)) {\n      onClickOutside();\n    }\n  };\n  React__namespace.useEffect(function () {\n    if (!closeOnClickOutside) {\n      return;\n    }\n    var eventOptions = {\n      capture: true\n    };\n    document.addEventListener('click', clickHandler, eventOptions);\n    return function () {\n      document.removeEventListener('click', clickHandler, eventOptions);\n    };\n  }, []);\n};\nvar useEscape = function (handler) {\n  var keyUpHandler = function (e) {\n    if (e.key === 'Escape') {\n      handler();\n    }\n  };\n  React__namespace.useEffect(function () {\n    document.addEventListener('keyup', keyUpHandler);\n    return function () {\n      document.removeEventListener('keyup', keyUpHandler);\n    };\n  }, []);\n};\nvar useLockScroll = function () {\n  React__namespace.useEffect(function () {\n    var originalStyle = window.getComputedStyle(document.body).overflow;\n    document.body.style.overflow = 'hidden';\n    return function () {\n      document.body.style.overflow = originalStyle;\n    };\n  }, []);\n};\nvar ModalBody = function (_a) {\n  var ariaControlsSuffix = _a.ariaControlsSuffix,\n    children = _a.children,\n    closeOnClickOutside = _a.closeOnClickOutside,\n    closeOnEscape = _a.closeOnEscape,\n    onToggle = _a.onToggle;\n  var contentRef = React__namespace.useRef();\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  useLockScroll();\n  useEscape(function () {\n    if (contentRef.current && closeOnEscape) {\n      onToggle();\n    }\n  });\n  useClickOutside(closeOnClickOutside, contentRef, onToggle);\n  useIsomorphicLayoutEffect(function () {\n    var contentEle = contentRef.current;\n    if (!contentEle) {\n      return;\n    }\n    var maxHeight = document.body.clientHeight * 0.75;\n    if (contentEle.getBoundingClientRect().height >= maxHeight) {\n      contentEle.style.overflow = 'auto';\n      contentEle.style.maxHeight = \"\".concat(maxHeight, \"px\");\n    }\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    \"aria-modal\": \"true\",\n    className: classNames({\n      'rpv-core__modal-body': true,\n      'rpv-core__modal-body--rtl': isRtl\n    }),\n    id: \"rpv-core__modal-body-\".concat(ariaControlsSuffix),\n    ref: contentRef,\n    role: \"dialog\",\n    tabIndex: -1\n  }, children);\n};\nvar ModalOverlay = function (_a) {\n  var children = _a.children;\n  return React__namespace.createElement(\"div\", {\n    className: \"rpv-core__modal-overlay\"\n  }, children);\n};\nexports.ToggleStatus = void 0;\n(function (ToggleStatus) {\n  ToggleStatus[\"Close\"] = \"Close\";\n  ToggleStatus[\"Open\"] = \"Open\";\n  ToggleStatus[\"Toggle\"] = \"Toggle\";\n})(exports.ToggleStatus || (exports.ToggleStatus = {}));\nvar useToggle = function (isOpened) {\n  var _a = React__namespace.useState(isOpened),\n    opened = _a[0],\n    setOpened = _a[1];\n  var toggle = function (status) {\n    switch (status) {\n      case exports.ToggleStatus.Close:\n        setOpened(false);\n        break;\n      case exports.ToggleStatus.Open:\n        setOpened(true);\n        break;\n      case exports.ToggleStatus.Toggle:\n      default:\n        setOpened(function (isOpened) {\n          return !isOpened;\n        });\n        break;\n    }\n  };\n  return {\n    opened: opened,\n    toggle: toggle\n  };\n};\nvar Portal = function (_a) {\n  var content = _a.content,\n    _b = _a.isOpened,\n    isOpened = _b === void 0 ? false : _b,\n    target = _a.target;\n  var _c = useToggle(isOpened),\n    opened = _c.opened,\n    toggle = _c.toggle;\n  return React__namespace.createElement(React__namespace.Fragment, null, target && target(toggle, opened), opened && content(toggle));\n};\nvar Modal = function (_a) {\n  var ariaControlsSuffix = _a.ariaControlsSuffix,\n    closeOnClickOutside = _a.closeOnClickOutside,\n    closeOnEscape = _a.closeOnEscape,\n    content = _a.content,\n    _b = _a.isOpened,\n    isOpened = _b === void 0 ? false : _b,\n    target = _a.target;\n  var controlsSuffix = ariaControlsSuffix || \"\".concat(uniqueId());\n  var renderTarget = function (toggle, opened) {\n    return React__namespace.createElement(\"div\", {\n      \"aria-expanded\": opened ? 'true' : 'false',\n      \"aria-haspopup\": \"dialog\",\n      \"aria-controls\": \"rpv-core__modal-body-\".concat(controlsSuffix)\n    }, target(toggle, opened));\n  };\n  var renderContent = function (toggle) {\n    return React__namespace.createElement(ModalOverlay, null, React__namespace.createElement(ModalBody, {\n      ariaControlsSuffix: controlsSuffix,\n      closeOnClickOutside: closeOnClickOutside,\n      closeOnEscape: closeOnEscape,\n      onToggle: toggle\n    }, content(toggle)));\n  };\n  return React__namespace.createElement(Portal, {\n    target: target ? renderTarget : null,\n    content: renderContent,\n    isOpened: isOpened\n  });\n};\nexports.Position = void 0;\n(function (Position) {\n  Position[\"TopLeft\"] = \"TOP_LEFT\";\n  Position[\"TopCenter\"] = \"TOP_CENTER\";\n  Position[\"TopRight\"] = \"TOP_RIGHT\";\n  Position[\"RightTop\"] = \"RIGHT_TOP\";\n  Position[\"RightCenter\"] = \"RIGHT_CENTER\";\n  Position[\"RightBottom\"] = \"RIGHT_BOTTOM\";\n  Position[\"BottomLeft\"] = \"BOTTOM_LEFT\";\n  Position[\"BottomCenter\"] = \"BOTTOM_CENTER\";\n  Position[\"BottomRight\"] = \"BOTTOM_RIGHT\";\n  Position[\"LeftTop\"] = \"LEFT_TOP\";\n  Position[\"LeftCenter\"] = \"LEFT_CENTER\";\n  Position[\"LeftBottom\"] = \"LEFT_BOTTOM\";\n})(exports.Position || (exports.Position = {}));\nvar calculatePosition = function (content, target, position, offset) {\n  var targetRect = target.getBoundingClientRect();\n  var contentRect = content.getBoundingClientRect();\n  var height = contentRect.height,\n    width = contentRect.width;\n  var top = 0;\n  var left = 0;\n  switch (position) {\n    case exports.Position.TopLeft:\n      top = targetRect.top - height;\n      left = targetRect.left;\n      break;\n    case exports.Position.TopCenter:\n      top = targetRect.top - height;\n      left = targetRect.left + targetRect.width / 2 - width / 2;\n      break;\n    case exports.Position.TopRight:\n      top = targetRect.top - height;\n      left = targetRect.left + targetRect.width - width;\n      break;\n    case exports.Position.RightTop:\n      top = targetRect.top;\n      left = targetRect.left + targetRect.width;\n      break;\n    case exports.Position.RightCenter:\n      top = targetRect.top + targetRect.height / 2 - height / 2;\n      left = targetRect.left + targetRect.width;\n      break;\n    case exports.Position.RightBottom:\n      top = targetRect.top + targetRect.height - height;\n      left = targetRect.left + targetRect.width;\n      break;\n    case exports.Position.BottomLeft:\n      top = targetRect.top + targetRect.height;\n      left = targetRect.left;\n      break;\n    case exports.Position.BottomCenter:\n      top = targetRect.top + targetRect.height;\n      left = targetRect.left + targetRect.width / 2 - width / 2;\n      break;\n    case exports.Position.BottomRight:\n      top = targetRect.top + targetRect.height;\n      left = targetRect.left + targetRect.width - width;\n      break;\n    case exports.Position.LeftTop:\n      top = targetRect.top;\n      left = targetRect.left - width;\n      break;\n    case exports.Position.LeftCenter:\n      top = targetRect.top + targetRect.height / 2 - height / 2;\n      left = targetRect.left - width;\n      break;\n    case exports.Position.LeftBottom:\n      top = targetRect.top + targetRect.height - height;\n      left = targetRect.left - width;\n      break;\n  }\n  return {\n    left: left + (offset.left || 0),\n    top: top + (offset.top || 0)\n  };\n};\nvar usePosition = function (contentRef, targetRef, anchorRef, position, offset) {\n  useIsomorphicLayoutEffect(function () {\n    var targetEle = targetRef.current;\n    var contentEle = contentRef.current;\n    var anchorEle = anchorRef.current;\n    if (!contentEle || !targetEle || !anchorEle) {\n      return;\n    }\n    var anchorRect = anchorEle.getBoundingClientRect();\n    var _a = calculatePosition(contentEle, targetEle, position, offset),\n      top = _a.top,\n      left = _a.left;\n    contentEle.style.top = \"\".concat(top - anchorRect.top, \"px\");\n    contentEle.style.left = \"\".concat(left - anchorRect.left, \"px\");\n  }, []);\n};\nvar Arrow = function (_a) {\n  var _b;\n  var customClassName = _a.customClassName,\n    position = _a.position;\n  return React__namespace.createElement(\"div\", {\n    className: classNames((_b = {\n      'rpv-core__arrow': true,\n      'rpv-core__arrow--tl': position === exports.Position.TopLeft,\n      'rpv-core__arrow--tc': position === exports.Position.TopCenter,\n      'rpv-core__arrow--tr': position === exports.Position.TopRight,\n      'rpv-core__arrow--rt': position === exports.Position.RightTop,\n      'rpv-core__arrow--rc': position === exports.Position.RightCenter,\n      'rpv-core__arrow--rb': position === exports.Position.RightBottom,\n      'rpv-core__arrow--bl': position === exports.Position.BottomLeft,\n      'rpv-core__arrow--bc': position === exports.Position.BottomCenter,\n      'rpv-core__arrow--br': position === exports.Position.BottomRight,\n      'rpv-core__arrow--lt': position === exports.Position.LeftTop,\n      'rpv-core__arrow--lc': position === exports.Position.LeftCenter,\n      'rpv-core__arrow--lb': position === exports.Position.LeftBottom\n    }, _b[\"\".concat(customClassName)] = customClassName !== '', _b))\n  });\n};\nvar PopoverBody = function (_a) {\n  var ariaControlsSuffix = _a.ariaControlsSuffix,\n    children = _a.children,\n    closeOnClickOutside = _a.closeOnClickOutside,\n    offset = _a.offset,\n    position = _a.position,\n    targetRef = _a.targetRef,\n    onClose = _a.onClose;\n  var contentRef = React__namespace.useRef();\n  var innerRef = React__namespace.useRef();\n  var anchorRef = React__namespace.useRef();\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  useClickOutside(closeOnClickOutside, contentRef, onClose);\n  usePosition(contentRef, targetRef, anchorRef, position, offset);\n  useIsomorphicLayoutEffect(function () {\n    var innerContentEle = innerRef.current;\n    if (!innerContentEle) {\n      return;\n    }\n    var maxHeight = document.body.clientHeight * 0.75;\n    if (innerContentEle.getBoundingClientRect().height >= maxHeight) {\n      innerContentEle.style.overflow = 'auto';\n      innerContentEle.style.maxHeight = \"\".concat(maxHeight, \"px\");\n    }\n  }, []);\n  var innerId = \"rpv-core__popover-body-inner-\".concat(ariaControlsSuffix);\n  return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(\"div\", {\n    ref: anchorRef,\n    style: {\n      left: 0,\n      position: 'absolute',\n      top: 0\n    }\n  }), React__namespace.createElement(\"div\", {\n    \"aria-describedby\": innerId,\n    className: classNames({\n      'rpv-core__popover-body': true,\n      'rpv-core__popover-body--rtl': isRtl\n    }),\n    id: \"rpv-core__popover-body-\".concat(ariaControlsSuffix),\n    ref: contentRef,\n    role: \"dialog\",\n    tabIndex: -1\n  }, React__namespace.createElement(Arrow, {\n    customClassName: \"rpv-core__popover-body-arrow\",\n    position: position\n  }), React__namespace.createElement(\"div\", {\n    id: innerId,\n    ref: innerRef\n  }, children)));\n};\nvar PopoverOverlay = function (_a) {\n  var closeOnEscape = _a.closeOnEscape,\n    onClose = _a.onClose;\n  var containerRef = React__namespace.useRef();\n  useEscape(function () {\n    if (containerRef.current && closeOnEscape) {\n      onClose();\n    }\n  });\n  return React__namespace.createElement(\"div\", {\n    className: \"rpv-core__popover-overlay\",\n    ref: containerRef\n  });\n};\nvar Popover = function (_a) {\n  var _b = _a.ariaHasPopup,\n    ariaHasPopup = _b === void 0 ? 'dialog' : _b,\n    ariaControlsSuffix = _a.ariaControlsSuffix,\n    closeOnClickOutside = _a.closeOnClickOutside,\n    closeOnEscape = _a.closeOnEscape,\n    content = _a.content,\n    _c = _a.lockScroll,\n    lockScroll = _c === void 0 ? true : _c,\n    offset = _a.offset,\n    position = _a.position,\n    target = _a.target;\n  var _d = useToggle(false),\n    opened = _d.opened,\n    toggle = _d.toggle;\n  var targetRef = React__namespace.useRef();\n  var controlsSuffix = React__namespace.useMemo(function () {\n    return ariaControlsSuffix || \"\".concat(uniqueId());\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    ref: targetRef,\n    \"aria-expanded\": opened ? 'true' : 'false',\n    \"aria-haspopup\": ariaHasPopup,\n    \"aria-controls\": \"rpv-core__popver-body-\".concat(controlsSuffix)\n  }, target(toggle, opened), opened && React__namespace.createElement(React__namespace.Fragment, null, lockScroll && React__namespace.createElement(PopoverOverlay, {\n    closeOnEscape: closeOnEscape,\n    onClose: toggle\n  }), React__namespace.createElement(PopoverBody, {\n    ariaControlsSuffix: controlsSuffix,\n    closeOnClickOutside: closeOnClickOutside,\n    offset: offset,\n    position: position,\n    targetRef: targetRef,\n    onClose: toggle\n  }, content(toggle))));\n};\nvar TooltipBody = function (_a) {\n  var ariaControlsSuffix = _a.ariaControlsSuffix,\n    children = _a.children,\n    contentRef = _a.contentRef,\n    offset = _a.offset,\n    position = _a.position,\n    targetRef = _a.targetRef;\n  var anchorRef = React__namespace.useRef();\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  usePosition(contentRef, targetRef, anchorRef, position, offset);\n  return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(\"div\", {\n    ref: anchorRef,\n    style: {\n      left: 0,\n      position: 'absolute',\n      top: 0\n    }\n  }), React__namespace.createElement(\"div\", {\n    className: classNames({\n      'rpv-core__tooltip-body': true,\n      'rpv-core__tooltip-body--rtl': isRtl\n    }),\n    id: \"rpv-core__tooltip-body-\".concat(ariaControlsSuffix),\n    ref: contentRef,\n    role: \"tooltip\"\n  }, React__namespace.createElement(Arrow, {\n    customClassName: \"rpv-core__tooltip-body-arrow\",\n    position: position\n  }), React__namespace.createElement(\"div\", {\n    className: \"rpv-core__tooltip-body-content\"\n  }, children)));\n};\nvar Tooltip = function (_a) {\n  var ariaControlsSuffix = _a.ariaControlsSuffix,\n    content = _a.content,\n    offset = _a.offset,\n    position = _a.position,\n    target = _a.target;\n  var _b = useToggle(false),\n    opened = _b.opened,\n    toggle = _b.toggle;\n  var targetRef = React__namespace.useRef();\n  var contentRef = React__namespace.useRef();\n  var controlsSuffix = React__namespace.useMemo(function () {\n    return ariaControlsSuffix || \"\".concat(uniqueId());\n  }, []);\n  useEscape(function () {\n    if (targetRef.current && document.activeElement && targetRef.current.contains(document.activeElement)) {\n      close();\n    }\n  });\n  var open = function () {\n    toggle(exports.ToggleStatus.Open);\n  };\n  var close = function () {\n    toggle(exports.ToggleStatus.Close);\n  };\n  var onBlur = function (e) {\n    var shouldHideTooltip = e.relatedTarget instanceof HTMLElement && e.currentTarget.parentElement && e.currentTarget.parentElement.contains(e.relatedTarget);\n    if (shouldHideTooltip) {\n      if (contentRef.current) {\n        contentRef.current.style.display = 'none';\n      }\n    } else {\n      close();\n    }\n  };\n  return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(\"div\", {\n    ref: targetRef,\n    \"aria-describedby\": \"rpv-core__tooltip-body-\".concat(controlsSuffix),\n    onBlur: onBlur,\n    onFocus: open,\n    onMouseEnter: open,\n    onMouseLeave: close\n  }, target), opened && React__namespace.createElement(TooltipBody, {\n    ariaControlsSuffix: controlsSuffix,\n    contentRef: contentRef,\n    offset: offset,\n    position: position,\n    targetRef: targetRef\n  }, content()));\n};\nfunction createStore(initialState) {\n  var state = initialState || {};\n  var listeners = {};\n  var update = function (key, data) {\n    var _a;\n    state = __assign(__assign({}, state), (_a = {}, _a[key] = data, _a));\n    (listeners[key] || []).forEach(function (handler) {\n      return handler(state[key]);\n    });\n  };\n  var get = function (key) {\n    return state[key];\n  };\n  return {\n    subscribe: function (key, handler) {\n      listeners[key] = (listeners[key] || []).concat(handler);\n    },\n    unsubscribe: function (key, handler) {\n      listeners[key] = (listeners[key] || []).filter(function (f) {\n        return f !== handler;\n      });\n    },\n    update: function (key, data) {\n      update(key, data);\n    },\n    updateCurrentValue: function (key, updater) {\n      var currentValue = get(key);\n      if (currentValue !== undefined) {\n        update(key, updater(currentValue));\n      }\n    },\n    get: function (key) {\n      return get(key);\n    }\n  };\n}\nexports.FullScreenMode = void 0;\n(function (FullScreenMode) {\n  FullScreenMode[\"Normal\"] = \"Normal\";\n  FullScreenMode[\"Entering\"] = \"Entering\";\n  FullScreenMode[\"Entered\"] = \"Entered\";\n  FullScreenMode[\"EnteredCompletely\"] = \"EnteredCompletely\";\n  FullScreenMode[\"Exitting\"] = \"Exitting\";\n  FullScreenMode[\"Exited\"] = \"Exited\";\n})(exports.FullScreenMode || (exports.FullScreenMode = {}));\nexports.LayerRenderStatus = void 0;\n(function (LayerRenderStatus) {\n  LayerRenderStatus[LayerRenderStatus[\"PreRender\"] = 0] = \"PreRender\";\n  LayerRenderStatus[LayerRenderStatus[\"DidRender\"] = 1] = \"DidRender\";\n})(exports.LayerRenderStatus || (exports.LayerRenderStatus = {}));\nexports.PageMode = void 0;\n(function (PageMode) {\n  PageMode[\"Attachments\"] = \"UseAttachments\";\n  PageMode[\"Bookmarks\"] = \"UseOutlines\";\n  PageMode[\"ContentGroup\"] = \"UseOC\";\n  PageMode[\"Default\"] = \"UserNone\";\n  PageMode[\"FullScreen\"] = \"FullScreen\";\n  PageMode[\"Thumbnails\"] = \"UseThumbs\";\n})(exports.PageMode || (exports.PageMode = {}));\nexports.PasswordStatus = void 0;\n(function (PasswordStatus) {\n  PasswordStatus[\"RequiredPassword\"] = \"RequiredPassword\";\n  PasswordStatus[\"WrongPassword\"] = \"WrongPassword\";\n})(exports.PasswordStatus || (exports.PasswordStatus = {}));\nexports.RotateDirection = void 0;\n(function (RotateDirection) {\n  RotateDirection[\"Backward\"] = \"Backward\";\n  RotateDirection[\"Forward\"] = \"Forward\";\n})(exports.RotateDirection || (exports.RotateDirection = {}));\nexports.ScrollMode = void 0;\n(function (ScrollMode) {\n  ScrollMode[\"Page\"] = \"Page\";\n  ScrollMode[\"Horizontal\"] = \"Horizontal\";\n  ScrollMode[\"Vertical\"] = \"Vertical\";\n  ScrollMode[\"Wrapped\"] = \"Wrapped\";\n})(exports.ScrollMode || (exports.ScrollMode = {}));\nexports.SpecialZoomLevel = void 0;\n(function (SpecialZoomLevel) {\n  SpecialZoomLevel[\"ActualSize\"] = \"ActualSize\";\n  SpecialZoomLevel[\"PageFit\"] = \"PageFit\";\n  SpecialZoomLevel[\"PageWidth\"] = \"PageWidth\";\n})(exports.SpecialZoomLevel || (exports.SpecialZoomLevel = {}));\nexports.ViewMode = void 0;\n(function (ViewMode) {\n  ViewMode[\"DualPage\"] = \"DualPage\";\n  ViewMode[\"DualPageWithCover\"] = \"DualPageWithCover\";\n  ViewMode[\"SinglePage\"] = \"SinglePage\";\n})(exports.ViewMode || (exports.ViewMode = {}));\nvar chunk = function (arr, size) {\n  return arr.reduce(function (acc, e, i) {\n    return i % size ? acc[acc.length - 1].push(e) : acc.push([e]), acc;\n  }, []);\n};\nvar isMac = function () {\n  return typeof window !== 'undefined' ? /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform) : false;\n};\nvar normalizeDestination = function (pageIndex, destArray) {\n  switch (destArray[1].name) {\n    case 'XYZ':\n      return {\n        bottomOffset: function (_, viewportHeight) {\n          return destArray[3] === null ? viewportHeight : destArray[3];\n        },\n        leftOffset: function (_, __) {\n          return destArray[2] === null ? 0 : destArray[2];\n        },\n        pageIndex: pageIndex,\n        scaleTo: destArray[4]\n      };\n    case 'Fit':\n    case 'FitB':\n      return {\n        bottomOffset: 0,\n        leftOffset: 0,\n        pageIndex: pageIndex,\n        scaleTo: exports.SpecialZoomLevel.PageFit\n      };\n    case 'FitH':\n    case 'FitBH':\n      return {\n        bottomOffset: destArray[2],\n        leftOffset: 0,\n        pageIndex: pageIndex,\n        scaleTo: exports.SpecialZoomLevel.PageWidth\n      };\n    default:\n      return {\n        bottomOffset: 0,\n        leftOffset: 0,\n        pageIndex: pageIndex,\n        scaleTo: 1\n      };\n  }\n};\nvar pageOutlinesMap = new Map();\nvar pagesMap = new Map();\nvar generateRefKey = function (doc, outline) {\n  return \"\".concat(doc.loadingTask.docId, \"___\").concat(outline.num, \"R\").concat(outline.gen === 0 ? '' : outline.gen);\n};\nvar getPageIndex = function (doc, outline) {\n  var key = generateRefKey(doc, outline);\n  return pageOutlinesMap.has(key) ? pageOutlinesMap.get(key) : null;\n};\nvar cacheOutlineRef = function (doc, outline, pageIndex) {\n  pageOutlinesMap.set(generateRefKey(doc, outline), pageIndex);\n};\nvar clearPagesCache = function () {\n  pageOutlinesMap.clear();\n  pagesMap.clear();\n};\nvar getPage = function (doc, pageIndex) {\n  if (!doc) {\n    return Promise.reject('The document is not loaded yet');\n  }\n  var pageKey = \"\".concat(doc.loadingTask.docId, \"___\").concat(pageIndex);\n  var page = pagesMap.get(pageKey);\n  if (page) {\n    return Promise.resolve(page);\n  }\n  return new Promise(function (resolve, _) {\n    doc.getPage(pageIndex + 1).then(function (page) {\n      pagesMap.set(pageKey, page);\n      if (page.ref) {\n        cacheOutlineRef(doc, page.ref, pageIndex);\n      }\n      resolve(page);\n    });\n  });\n};\nvar getDestination = function (doc, dest) {\n  return new Promise(function (res) {\n    new Promise(function (resolve) {\n      if (typeof dest === 'string') {\n        doc.getDestination(dest).then(function (destArray) {\n          resolve(destArray);\n        });\n      } else {\n        resolve(dest);\n      }\n    }).then(function (destArray) {\n      if ('object' === typeof destArray[0] && destArray[0] !== null) {\n        var outlineRef_1 = destArray[0];\n        var pageIndex = getPageIndex(doc, outlineRef_1);\n        if (pageIndex === null) {\n          doc.getPageIndex(outlineRef_1).then(function (pageIndex) {\n            cacheOutlineRef(doc, outlineRef_1, pageIndex);\n            getDestination(doc, dest).then(function (result) {\n              return res(result);\n            });\n          });\n        } else {\n          res(normalizeDestination(pageIndex, destArray));\n        }\n      } else {\n        var target = normalizeDestination(destArray[0], destArray);\n        res(target);\n      }\n    });\n  });\n};\nvar useRunOnce = function (cb, condition) {\n  var isCalledRef = React__namespace.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (condition && !isCalledRef.current) {\n      isCalledRef.current = true;\n      cb();\n    }\n  }, [cb, condition]);\n};\nvar useTrackResize = function (_a) {\n  var targetRef = _a.targetRef,\n    onResize = _a.onResize;\n  useIsomorphicLayoutEffect(function () {\n    var io = new ResizeObserver(function (entries) {\n      entries.forEach(function (entry) {\n        onResize(entry.target);\n      });\n    });\n    var container = targetRef.current;\n    if (!container) {\n      return;\n    }\n    io.observe(container);\n    return function () {\n      io.unobserve(container);\n    };\n  }, []);\n};\nvar AnnotationBorderStyleType;\n(function (AnnotationBorderStyleType) {\n  AnnotationBorderStyleType[AnnotationBorderStyleType[\"Solid\"] = 1] = \"Solid\";\n  AnnotationBorderStyleType[AnnotationBorderStyleType[\"Dashed\"] = 2] = \"Dashed\";\n  AnnotationBorderStyleType[AnnotationBorderStyleType[\"Beveled\"] = 3] = \"Beveled\";\n  AnnotationBorderStyleType[AnnotationBorderStyleType[\"Inset\"] = 4] = \"Inset\";\n  AnnotationBorderStyleType[AnnotationBorderStyleType[\"Underline\"] = 5] = \"Underline\";\n})(AnnotationBorderStyleType || (AnnotationBorderStyleType = {}));\nvar dateRegex = new RegExp('^D:' + '(\\\\d{4})' + '(\\\\d{2})?' + '(\\\\d{2})?' + '(\\\\d{2})?' + '(\\\\d{2})?' + '(\\\\d{2})?' + '([Z|+|-])?' + '(\\\\d{2})?' + \"'?\" + '(\\\\d{2})?' + \"'?\");\nvar parse = function (value, min, max, defaultValue) {\n  var parsed = parseInt(value, 10);\n  return parsed >= min && parsed <= max ? parsed : defaultValue;\n};\nvar convertDate = function (input) {\n  var matches = dateRegex.exec(input);\n  if (!matches) {\n    return null;\n  }\n  var year = parseInt(matches[1], 10);\n  var month = parse(matches[2], 1, 12, 1) - 1;\n  var day = parse(matches[3], 1, 31, 1);\n  var hour = parse(matches[4], 0, 23, 0);\n  var minute = parse(matches[5], 0, 59, 0);\n  var second = parse(matches[6], 0, 59, 0);\n  var universalTimeRelation = matches[7] || 'Z';\n  var offsetHour = parse(matches[8], 0, 23, 0);\n  var offsetMinute = parse(matches[9], 0, 59, 0);\n  switch (universalTimeRelation) {\n    case '-':\n      hour += offsetHour;\n      minute += offsetMinute;\n      break;\n    case '+':\n      hour -= offsetHour;\n      minute -= offsetMinute;\n      break;\n  }\n  return new Date(Date.UTC(year, month, day, hour, minute, second));\n};\nvar getContents = function (annotation) {\n  return annotation.contentsObj ? annotation.contentsObj.str : annotation.contents || '';\n};\nvar getTitle = function (annotation) {\n  return annotation.titleObj ? annotation.titleObj.str : annotation.title || '';\n};\nvar PopupWrapper = function (_a) {\n  var annotation = _a.annotation;\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  var containerRef = React__namespace.useRef();\n  var dateStr = '';\n  if (annotation.modificationDate) {\n    var date = convertDate(annotation.modificationDate);\n    dateStr = date ? \"\".concat(date.toLocaleDateString(), \", \").concat(date.toLocaleTimeString()) : '';\n  }\n  React__namespace.useLayoutEffect(function () {\n    var containerEle = containerRef.current;\n    if (!containerEle) {\n      return;\n    }\n    var annotationEle = document.querySelector(\"[data-annotation-id=\\\"\".concat(annotation.id, \"\\\"]\"));\n    if (!annotationEle) {\n      return;\n    }\n    var ele = annotationEle;\n    ele.style.zIndex += 1;\n    return function () {\n      ele.style.zIndex = \"\".concat(parseInt(ele.style.zIndex, 10) - 1);\n    };\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    ref: containerRef,\n    className: classNames({\n      'rpv-core__annotation-popup-wrapper': true,\n      'rpv-core__annotation-popup-wrapper--rtl': isRtl\n    }),\n    style: {\n      top: annotation.annotationType === exports.AnnotationType.Popup ? '' : '100%'\n    }\n  }, title && React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(\"div\", {\n    className: classNames({\n      'rpv-core__annotation-popup-title': true,\n      'rpv-core__annotation-popup-title--ltr': !isRtl,\n      'rpv-core__annotation-popup-title--rtl': isRtl\n    })\n  }, title), React__namespace.createElement(\"div\", {\n    className: \"rpv-core__annotation-popup-date\"\n  }, dateStr)), contents && React__namespace.createElement(\"div\", {\n    className: \"rpv-core__annotation-popup-content\"\n  }, contents.split('\\n').map(function (item, index) {\n    return React__namespace.createElement(React__namespace.Fragment, {\n      key: index\n    }, item, React__namespace.createElement(\"br\", null));\n  })));\n};\nvar TogglePopupBy;\n(function (TogglePopupBy) {\n  TogglePopupBy[\"Click\"] = \"Click\";\n  TogglePopupBy[\"Hover\"] = \"Hover\";\n})(TogglePopupBy || (TogglePopupBy = {}));\nvar useTogglePopup = function () {\n  var _a = useToggle(false),\n    opened = _a.opened,\n    toggle = _a.toggle;\n  var _b = React__namespace.useState(TogglePopupBy.Hover),\n    togglePopupBy = _b[0],\n    setTooglePopupBy = _b[1];\n  var toggleOnClick = function () {\n    switch (togglePopupBy) {\n      case TogglePopupBy.Click:\n        opened && setTooglePopupBy(TogglePopupBy.Hover);\n        toggle(exports.ToggleStatus.Toggle);\n        break;\n      case TogglePopupBy.Hover:\n        setTooglePopupBy(TogglePopupBy.Click);\n        toggle(exports.ToggleStatus.Open);\n        break;\n    }\n  };\n  var openOnHover = function () {\n    togglePopupBy === TogglePopupBy.Hover && toggle(exports.ToggleStatus.Open);\n  };\n  var closeOnHover = function () {\n    togglePopupBy === TogglePopupBy.Hover && toggle(exports.ToggleStatus.Close);\n  };\n  return {\n    opened: opened,\n    closeOnHover: closeOnHover,\n    openOnHover: openOnHover,\n    toggleOnClick: toggleOnClick\n  };\n};\nvar Annotation = function (_a) {\n  var annotation = _a.annotation,\n    children = _a.children,\n    ignoreBorder = _a.ignoreBorder,\n    hasPopup = _a.hasPopup,\n    isRenderable = _a.isRenderable,\n    page = _a.page,\n    viewport = _a.viewport;\n  var rect = annotation.rect;\n  var _b = useTogglePopup(),\n    closeOnHover = _b.closeOnHover,\n    opened = _b.opened,\n    openOnHover = _b.openOnHover,\n    toggleOnClick = _b.toggleOnClick;\n  var normalizeRect = function (r) {\n    return [Math.min(r[0], r[2]), Math.min(r[1], r[3]), Math.max(r[0], r[2]), Math.max(r[1], r[3])];\n  };\n  var bound = normalizeRect([rect[0], page.view[3] + page.view[1] - rect[1], rect[2], page.view[3] + page.view[1] - rect[3]]);\n  var width = rect[2] - rect[0];\n  var height = rect[3] - rect[1];\n  var styles = {\n    borderColor: '',\n    borderRadius: '',\n    borderStyle: '',\n    borderWidth: ''\n  };\n  if (!ignoreBorder && annotation.borderStyle.width > 0) {\n    switch (annotation.borderStyle.style) {\n      case AnnotationBorderStyleType.Dashed:\n        styles.borderStyle = 'dashed';\n        break;\n      case AnnotationBorderStyleType.Solid:\n        styles.borderStyle = 'solid';\n        break;\n      case AnnotationBorderStyleType.Underline:\n        styles = Object.assign({\n          borderBottomStyle: 'solid'\n        }, styles);\n        break;\n      case AnnotationBorderStyleType.Beveled:\n      case AnnotationBorderStyleType.Inset:\n    }\n    var borderWidth = annotation.borderStyle.width;\n    styles.borderWidth = \"\".concat(borderWidth, \"px\");\n    if (annotation.borderStyle.style !== AnnotationBorderStyleType.Underline) {\n      width = width - 2 * borderWidth;\n      height = height - 2 * borderWidth;\n    }\n    var _c = annotation.borderStyle,\n      horizontalCornerRadius = _c.horizontalCornerRadius,\n      verticalCornerRadius = _c.verticalCornerRadius;\n    if (horizontalCornerRadius > 0 || verticalCornerRadius > 0) {\n      styles.borderRadius = \"\".concat(horizontalCornerRadius, \"px / \").concat(verticalCornerRadius, \"px\");\n    }\n    annotation.color ? styles.borderColor = \"rgb(\".concat(annotation.color[0] | 0, \", \").concat(annotation.color[1] | 0, \", \").concat(annotation.color[2] | 0, \")\") : styles.borderWidth = '0';\n  }\n  return React__namespace.createElement(React__namespace.Fragment, null, isRenderable && children({\n    popup: {\n      opened: opened,\n      closeOnHover: closeOnHover,\n      openOnHover: openOnHover,\n      toggleOnClick: toggleOnClick\n    },\n    slot: {\n      attrs: {\n        style: Object.assign({\n          height: \"\".concat(height, \"px\"),\n          left: \"\".concat(bound[0], \"px\"),\n          top: \"\".concat(bound[1], \"px\"),\n          transform: \"matrix(\".concat(viewport.transform.join(','), \")\"),\n          transformOrigin: \"-\".concat(bound[0], \"px -\").concat(bound[1], \"px\"),\n          width: \"\".concat(width, \"px\")\n        }, styles)\n      },\n      children: React__namespace.createElement(React__namespace.Fragment, null, hasPopup && opened && React__namespace.createElement(PopupWrapper, {\n        annotation: annotation\n      }))\n    }\n  }));\n};\nvar Caret = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--caret\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), props.slot.children);\n  });\n};\nvar Circle = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  var rect = annotation.rect;\n  var width = rect[2] - rect[0];\n  var height = rect[3] - rect[1];\n  var borderWidth = annotation.borderStyle.width;\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--circle\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), React__namespace.createElement(\"svg\", {\n      height: \"\".concat(height, \"px\"),\n      preserveAspectRatio: \"none\",\n      version: \"1.1\",\n      viewBox: \"0 0 \".concat(width, \" \").concat(height),\n      width: \"\".concat(width, \"px\")\n    }, React__namespace.createElement(\"circle\", {\n      cy: height / 2,\n      fill: \"none\",\n      rx: width / 2 - borderWidth / 2,\n      ry: height / 2 - borderWidth / 2,\n      stroke: \"transparent\",\n      strokeWidth: borderWidth || 1\n    })), props.slot.children);\n  });\n};\nvar getFileName = function (url) {\n  var str = url.split('/').pop();\n  return str ? str.split('#')[0].split('?')[0] : url;\n};\nvar downloadFile = function (url, data) {\n  var blobUrl = typeof data === 'string' ? '' : URL.createObjectURL(new Blob([data], {\n    type: ''\n  }));\n  var link = document.createElement('a');\n  link.style.display = 'none';\n  link.href = blobUrl || url;\n  link.setAttribute('download', getFileName(url));\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  if (blobUrl) {\n    URL.revokeObjectURL(blobUrl);\n  }\n};\nvar FileAttachment = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var hasPopup = annotation.hasPopup === false && (!!title || !!contents);\n  var doubleClick = function () {\n    var file = annotation.file;\n    file && downloadFile(file.filename, file.content);\n  };\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: true,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--file-attachment\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onDoubleClick: doubleClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), props.slot.children);\n  });\n};\nvar FreeText = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--free-text\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), props.slot.children);\n  });\n};\nvar Popup = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(title || contents);\n  var ignoredParents = ['Circle', 'Ink', 'Line', 'Polygon', 'PolyLine', 'Square'];\n  var hasPopup = !annotation.parentType || ignoredParents.indexOf(annotation.parentType) !== -1;\n  useIsomorphicLayoutEffect(function () {\n    if (!annotation.parentId) {\n      return;\n    }\n    var parent = document.querySelector(\"[data-annotation-id=\\\"\".concat(annotation.parentId, \"\\\"]\"));\n    var container = document.querySelector(\"[data-annotation-id=\\\"\".concat(annotation.id, \"\\\"]\"));\n    if (!parent || !container) {\n      return;\n    }\n    var left = parseFloat(parent.style.left);\n    var top = parseFloat(parent.style.top) + parseFloat(parent.style.height);\n    container.style.left = \"\".concat(left, \"px\");\n    container.style.top = \"\".concat(top, \"px\");\n    container.style.transformOrigin = \"-\".concat(left, \"px -\").concat(top, \"px\");\n  }, []);\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: false,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--popup\",\n      \"data-annotation-id\": annotation.id\n    }), React__namespace.createElement(PopupWrapper, {\n      annotation: annotation\n    }));\n  });\n};\nvar Highlight = function (_a) {\n  var annotation = _a.annotation,\n    childAnnotation = _a.childAnnotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  var hasQuadPoints = annotation.quadPoints && annotation.quadPoints.length > 0;\n  if (hasQuadPoints) {\n    var annotations = annotation.quadPoints.map(function (quadPoint) {\n      return Object.assign({}, annotation, {\n        rect: [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y],\n        quadPoints: []\n      });\n    });\n    return React__namespace.createElement(React__namespace.Fragment, null, annotations.map(function (ann, index) {\n      return React__namespace.createElement(Highlight, {\n        key: index,\n        annotation: ann,\n        childAnnotation: childAnnotation,\n        page: page,\n        viewport: viewport\n      });\n    }));\n  }\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--highlight\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), props.slot.children), childAnnotation && childAnnotation.annotationType === exports.AnnotationType.Popup && props.popup.opened && React__namespace.createElement(Popup, {\n      annotation: childAnnotation,\n      page: page,\n      viewport: viewport\n    }));\n  });\n};\nvar Ink = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  var rect = annotation.rect;\n  var width = rect[2] - rect[0];\n  var height = rect[3] - rect[1];\n  var borderWidth = annotation.borderStyle.width;\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--ink\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), annotation.inkLists && annotation.inkLists.length && React__namespace.createElement(\"svg\", {\n      height: \"\".concat(height, \"px\"),\n      preserveAspectRatio: \"none\",\n      version: \"1.1\",\n      viewBox: \"0 0 \".concat(width, \" \").concat(height),\n      width: \"\".concat(width, \"px\")\n    }, annotation.inkLists.map(function (inkList, index) {\n      return React__namespace.createElement(\"polyline\", {\n        key: index,\n        fill: \"none\",\n        stroke: \"transparent\",\n        strokeWidth: borderWidth || 1,\n        points: inkList.map(function (item) {\n          return \"\".concat(item.x - rect[0], \",\").concat(rect[3] - item.y);\n        }).join(' ')\n      });\n    })), props.slot.children);\n  });\n};\nvar Line = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  var rect = annotation.rect;\n  var width = rect[2] - rect[0];\n  var height = rect[3] - rect[1];\n  var borderWidth = annotation.borderStyle.width;\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--line\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), React__namespace.createElement(\"svg\", {\n      height: \"\".concat(height, \"px\"),\n      preserveAspectRatio: \"none\",\n      version: \"1.1\",\n      viewBox: \"0 0 \".concat(width, \" \").concat(height),\n      width: \"\".concat(width, \"px\")\n    }, React__namespace.createElement(\"line\", {\n      stroke: \"transparent\",\n      strokeWidth: borderWidth || 1,\n      x1: rect[2] - annotation.lineCoordinates[0],\n      x2: rect[2] - annotation.lineCoordinates[2],\n      y1: rect[3] - annotation.lineCoordinates[1],\n      y2: rect[3] - annotation.lineCoordinates[3]\n    })), props.slot.children);\n  });\n};\nvar INVALID_PROTOCOL = /^([^\\w]*)(javascript|data|vbscript)/im;\nvar HTML_ENTITIES = /&#(\\w+)(^\\w|;)?/g;\nvar CTRL_CHARS = /[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200D\\uFEFF]/gim;\nvar URL_SCHEME = /^([^:]+):/gm;\nvar decodeHtmlEntities = function (str) {\n  return str.replace(HTML_ENTITIES, function (_, dec) {\n    return String.fromCharCode(dec);\n  });\n};\nvar sanitizeUrl = function (url, defaultUrl) {\n  if (defaultUrl === void 0) {\n    defaultUrl = 'about:blank';\n  }\n  var result = decodeHtmlEntities(url || '').replace(CTRL_CHARS, '').trim();\n  if (!result) {\n    return defaultUrl;\n  }\n  var firstChar = result[0];\n  if (firstChar === '.' || firstChar === '/') {\n    return result;\n  }\n  var parsedUrlScheme = result.match(URL_SCHEME);\n  if (!parsedUrlScheme) {\n    return result;\n  }\n  var scheme = parsedUrlScheme[0];\n  return INVALID_PROTOCOL.test(scheme) ? defaultUrl : result;\n};\nvar Link = function (_a) {\n  var _b;\n  var annotation = _a.annotation,\n    annotationContainerRef = _a.annotationContainerRef,\n    doc = _a.doc,\n    outlines = _a.outlines,\n    page = _a.page,\n    pageIndex = _a.pageIndex,\n    scale = _a.scale,\n    viewport = _a.viewport,\n    onExecuteNamedAction = _a.onExecuteNamedAction,\n    onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation,\n    onJumpToDest = _a.onJumpToDest;\n  var elementRef = React__namespace.useRef();\n  var title = outlines && outlines.length && annotation.dest && typeof annotation.dest === 'string' ? (_b = outlines.find(function (item) {\n    return item.dest === annotation.dest;\n  })) === null || _b === void 0 ? void 0 : _b.title : '';\n  var link = function (e) {\n    e.preventDefault();\n    annotation.action ? onExecuteNamedAction(annotation.action) : getDestination(doc, annotation.dest).then(function (target) {\n      var element = elementRef.current;\n      var annotationContainer = annotationContainerRef.current;\n      if (element && annotationContainer) {\n        var linkRect = element.getBoundingClientRect();\n        annotationContainer.style.setProperty('height', '100%');\n        annotationContainer.style.setProperty('width', '100%');\n        var annotationLayerRect = annotationContainer.getBoundingClientRect();\n        annotationContainer.style.removeProperty('height');\n        annotationContainer.style.removeProperty('width');\n        var leftOffset = (linkRect.left - annotationLayerRect.left) / scale;\n        var bottomOffset = (annotationLayerRect.bottom - linkRect.bottom + linkRect.height) / scale;\n        onJumpFromLinkAnnotation({\n          bottomOffset: bottomOffset,\n          label: title,\n          leftOffset: leftOffset,\n          pageIndex: pageIndex\n        });\n      }\n      onJumpToDest(target);\n    });\n  };\n  var isRenderable = !!(annotation.url || annotation.dest || annotation.action || annotation.unsafeUrl);\n  var attrs = {};\n  if (annotation.url || annotation.unsafeUrl) {\n    var targetUrl = sanitizeUrl(annotation.url || annotation.unsafeUrl, '');\n    if (targetUrl) {\n      attrs = {\n        'data-target': 'external',\n        href: targetUrl,\n        rel: 'noopener noreferrer nofollow',\n        target: annotation.newWindow ? '_blank' : '',\n        title: targetUrl\n      };\n    } else {\n      isRenderable = false;\n    }\n  } else {\n    attrs = {\n      href: '',\n      'data-annotation-link': annotation.id,\n      onClick: link\n    };\n  }\n  if (title) {\n    attrs = Object.assign({}, attrs, {\n      title: title,\n      'aria-label': title\n    });\n  }\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: false,\n    ignoreBorder: false,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--link\",\n      \"data-annotation-id\": annotation.id,\n      \"data-testid\": \"core__annotation--link-\".concat(annotation.id)\n    }), React__namespace.createElement(\"a\", __assign({\n      ref: elementRef\n    }, attrs)));\n  });\n};\nvar Polygon = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  var rect = annotation.rect;\n  var width = rect[2] - rect[0];\n  var height = rect[3] - rect[1];\n  var borderWidth = annotation.borderStyle.width;\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--polygon\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), annotation.vertices && annotation.vertices.length && React__namespace.createElement(\"svg\", {\n      height: \"\".concat(height, \"px\"),\n      preserveAspectRatio: \"none\",\n      version: \"1.1\",\n      viewBox: \"0 0 \".concat(width, \" \").concat(height),\n      width: \"\".concat(width, \"px\")\n    }, React__namespace.createElement(\"polygon\", {\n      fill: \"none\",\n      stroke: \"transparent\",\n      strokeWidth: borderWidth || 1,\n      points: annotation.vertices.map(function (item) {\n        return \"\".concat(item.x - rect[0], \",\").concat(rect[3] - item.y);\n      }).join(' ')\n    })), props.slot.children);\n  });\n};\nvar Polyline = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  var rect = annotation.rect;\n  var width = rect[2] - rect[0];\n  var height = rect[3] - rect[1];\n  var borderWidth = annotation.borderStyle.width;\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--polyline\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), annotation.vertices && annotation.vertices.length && React__namespace.createElement(\"svg\", {\n      height: \"\".concat(height, \"px\"),\n      preserveAspectRatio: \"none\",\n      version: \"1.1\",\n      viewBox: \"0 0 \".concat(width, \" \").concat(height),\n      width: \"\".concat(width, \"px\")\n    }, React__namespace.createElement(\"polyline\", {\n      fill: \"none\",\n      stroke: \"transparent\",\n      strokeWidth: borderWidth || 1,\n      points: annotation.vertices.map(function (item) {\n        return \"\".concat(item.x - rect[0], \",\").concat(rect[3] - item.y);\n      }).join(' ')\n    })), props.slot.children);\n  });\n};\nvar Square = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  var rect = annotation.rect;\n  var width = rect[2] - rect[0];\n  var height = rect[3] - rect[1];\n  var borderWidth = annotation.borderStyle.width;\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--square\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), React__namespace.createElement(\"svg\", {\n      height: \"\".concat(height, \"px\"),\n      preserveAspectRatio: \"none\",\n      version: \"1.1\",\n      viewBox: \"0 0 \".concat(width, \" \").concat(height),\n      width: \"\".concat(width, \"px\")\n    }, React__namespace.createElement(\"rect\", {\n      height: height - borderWidth,\n      fill: \"none\",\n      stroke: \"transparent\",\n      strokeWidth: borderWidth || 1,\n      x: borderWidth / 2,\n      y: borderWidth / 2,\n      width: width - borderWidth\n    })), props.slot.children);\n  });\n};\nvar Squiggly = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--squiggly\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), props.slot.children);\n  });\n};\nvar Stamp = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--stamp\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), props.slot.children);\n  });\n};\nvar StrikeOut = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--strike-out\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), props.slot.children);\n  });\n};\nvar CommentIcon = function () {\n  return React__namespace.createElement(Icon, {\n    size: 16\n  }, React__namespace.createElement(\"path\", {\n    d: \"M.5,16.5a1,1,0,0,0,1,1h2v4l4-4h15a1,1,0,0,0,1-1V3.5a1,1,0,0,0-1-1H1.5a1,1,0,0,0-1,1Z\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M7.25,9.75A.25.25,0,1,1,7,10a.25.25,0,0,1,.25-.25\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M12,9.75a.25.25,0,1,1-.25.25A.25.25,0,0,1,12,9.75\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M16.75,9.75a.25.25,0,1,1-.25.25.25.25,0,0,1,.25-.25\"\n  }));\n};\nvar HelpIcon = function () {\n  return React__namespace.createElement(Icon, {\n    size: 16\n  }, React__namespace.createElement(\"path\", {\n    d: \"M0.500 12.001 A11.500 11.500 0 1 0 23.500 12.001 A11.500 11.500 0 1 0 0.500 12.001 Z\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M6.000 12.001 A6.000 6.000 0 1 0 18.000 12.001 A6.000 6.000 0 1 0 6.000 12.001 Z\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M21.423 5.406L17.415 9.414\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M14.587 6.585L18.607 2.565\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M5.405 21.424L9.413 17.416\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M6.585 14.588L2.577 18.596\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M18.602 21.419L14.595 17.412\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M17.419 14.58L21.428 18.589\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M2.582 5.399L6.588 9.406\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M9.421 6.581L5.412 2.572\"\n  }));\n};\nvar KeyIcon = function () {\n  return React__namespace.createElement(Icon, {\n    size: 16\n  }, React__namespace.createElement(\"path\", {\n    d: \"M4.000 18.500 A1.500 1.500 0 1 0 7.000 18.500 A1.500 1.500 0 1 0 4.000 18.500 Z\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M20.5.5l-9.782,9.783a7,7,0,1,0,3,3L17,10h1.5V8.5L19,8h1.5V6.5L21,6h1.5V4.5l1-1V.5Z\"\n  }));\n};\nvar NoteIcon = function () {\n  return React__namespace.createElement(Icon, {\n    size: 16\n  }, React__namespace.createElement(\"path\", {\n    d: \"M2.000 2.500 L22.000 2.500 L22.000 23.500 L2.000 23.500 Z\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M6 4.5L6 0.5\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M18 4.5L18 0.5\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M10 4.5L10 0.5\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M14 4.5L14 0.5\"\n  }));\n};\nvar ParagraphIcon = function () {\n  return React__namespace.createElement(Icon, {\n    size: 16\n  }, React__namespace.createElement(\"path\", {\n    d: \"M17.5 0.498L17.5 23.498\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M10.5 0.498L10.5 23.498\"\n  }), React__namespace.createElement(\"path\", {\n    d: \"M23.5.5H6.5a6,6,0,0,0,0,12h4\"\n  }));\n};\nvar TriangleIcon = function () {\n  return React__namespace.createElement(Icon, {\n    size: 16\n  }, React__namespace.createElement(\"path\", {\n    d: \"M2.5 22.995L12 6.005 21.5 22.995 2.5 22.995z\"\n  }));\n};\nvar Text = function (_a) {\n  var annotation = _a.annotation,\n    childAnnotation = _a.childAnnotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  var name = annotation.name ? annotation.name.toLowerCase() : '';\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: false,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--text\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), name && React__namespace.createElement(\"div\", {\n      className: \"rpv-core__annotation-text-icon\"\n    }, name === 'check' && React__namespace.createElement(CheckIcon, null), name === 'comment' && React__namespace.createElement(CommentIcon, null), name === 'help' && React__namespace.createElement(HelpIcon, null), name === 'insert' && React__namespace.createElement(TriangleIcon, null), name === 'key' && React__namespace.createElement(KeyIcon, null), name === 'note' && React__namespace.createElement(NoteIcon, null), (name === 'newparagraph' || name === 'paragraph') && React__namespace.createElement(ParagraphIcon, null)), props.slot.children), childAnnotation && childAnnotation.annotationType === exports.AnnotationType.Popup && props.popup.opened && React__namespace.createElement(Popup, {\n      annotation: childAnnotation,\n      page: page,\n      viewport: viewport\n    }));\n  });\n};\nvar Underline = function (_a) {\n  var annotation = _a.annotation,\n    page = _a.page,\n    viewport = _a.viewport;\n  var hasPopup = annotation.hasPopup === false;\n  var title = getTitle(annotation);\n  var contents = getContents(annotation);\n  var isRenderable = !!(annotation.hasPopup || title || contents);\n  return React__namespace.createElement(Annotation, {\n    annotation: annotation,\n    hasPopup: hasPopup,\n    ignoreBorder: true,\n    isRenderable: isRenderable,\n    page: page,\n    viewport: viewport\n  }, function (props) {\n    return React__namespace.createElement(\"div\", __assign({}, props.slot.attrs, {\n      className: \"rpv-core__annotation rpv-core__annotation--underline\",\n      \"data-annotation-id\": annotation.id,\n      onClick: props.popup.toggleOnClick,\n      onMouseEnter: props.popup.openOnHover,\n      onMouseLeave: props.popup.closeOnHover\n    }), props.slot.children);\n  });\n};\nvar AnnotationLayerBody = function (_a) {\n  var annotations = _a.annotations,\n    doc = _a.doc,\n    outlines = _a.outlines,\n    page = _a.page,\n    pageIndex = _a.pageIndex,\n    plugins = _a.plugins,\n    rotation = _a.rotation,\n    scale = _a.scale,\n    onExecuteNamedAction = _a.onExecuteNamedAction,\n    onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation,\n    onJumpToDest = _a.onJumpToDest;\n  var containerRef = React__namespace.useRef();\n  var viewport = page.getViewport({\n    rotation: rotation,\n    scale: scale\n  });\n  var clonedViewPort = viewport.clone({\n    dontFlip: true\n  });\n  var filterAnnotations = annotations.filter(function (annotation) {\n    return !annotation.parentId;\n  });\n  useIsomorphicLayoutEffect(function () {\n    var container = containerRef.current;\n    if (!container) {\n      return;\n    }\n    plugins.forEach(function (plugin) {\n      if (plugin.onAnnotationLayerRender) {\n        plugin.onAnnotationLayerRender({\n          annotations: filterAnnotations,\n          container: container,\n          pageIndex: pageIndex,\n          rotation: rotation,\n          scale: scale\n        });\n      }\n    });\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    ref: containerRef,\n    className: \"rpv-core__annotation-layer\",\n    \"data-testid\": \"core__annotation-layer-\".concat(pageIndex)\n  }, filterAnnotations.map(function (annotation) {\n    var childAnnotation = annotations.find(function (item) {\n      return item.parentId === annotation.id;\n    });\n    switch (annotation.annotationType) {\n      case exports.AnnotationType.Caret:\n        return React__namespace.createElement(Caret, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Circle:\n        return React__namespace.createElement(Circle, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.FileAttachment:\n        return React__namespace.createElement(FileAttachment, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.FreeText:\n        return React__namespace.createElement(FreeText, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Highlight:\n        return React__namespace.createElement(Highlight, {\n          key: annotation.id,\n          annotation: annotation,\n          childAnnotation: childAnnotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Ink:\n        return React__namespace.createElement(Ink, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Line:\n        return React__namespace.createElement(Line, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Link:\n        return React__namespace.createElement(Link, {\n          key: annotation.id,\n          annotation: annotation,\n          annotationContainerRef: containerRef,\n          doc: doc,\n          outlines: outlines,\n          page: page,\n          pageIndex: pageIndex,\n          scale: scale,\n          viewport: clonedViewPort,\n          onExecuteNamedAction: onExecuteNamedAction,\n          onJumpFromLinkAnnotation: onJumpFromLinkAnnotation,\n          onJumpToDest: onJumpToDest\n        });\n      case exports.AnnotationType.Polygon:\n        return React__namespace.createElement(Polygon, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Polyline:\n        return React__namespace.createElement(Polyline, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Popup:\n        return React__namespace.createElement(Popup, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Square:\n        return React__namespace.createElement(Square, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Squiggly:\n        return React__namespace.createElement(Squiggly, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Stamp:\n        return React__namespace.createElement(Stamp, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.StrikeOut:\n        return React__namespace.createElement(StrikeOut, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Text:\n        return React__namespace.createElement(Text, {\n          key: annotation.id,\n          annotation: annotation,\n          childAnnotation: childAnnotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      case exports.AnnotationType.Underline:\n        return React__namespace.createElement(Underline, {\n          key: annotation.id,\n          annotation: annotation,\n          page: page,\n          viewport: clonedViewPort\n        });\n      default:\n        return React__namespace.createElement(React__namespace.Fragment, {\n          key: annotation.id\n        });\n    }\n  }));\n};\nvar AnnotationLoader = function (_a) {\n  var page = _a.page,\n    renderAnnotations = _a.renderAnnotations;\n  var isMounted = useIsMounted();\n  var _b = React__namespace.useState({\n      loading: true,\n      annotations: []\n    }),\n    status = _b[0],\n    setStatus = _b[1];\n  React__namespace.useEffect(function () {\n    page.getAnnotations({\n      intent: 'display'\n    }).then(function (result) {\n      if (isMounted.current) {\n        setStatus({\n          loading: false,\n          annotations: result\n        });\n      }\n    });\n  }, []);\n  return status.loading ? React__namespace.createElement(React__namespace.Fragment, null) : renderAnnotations(status.annotations);\n};\nvar AnnotationLayer = function (_a) {\n  var doc = _a.doc,\n    outlines = _a.outlines,\n    page = _a.page,\n    pageIndex = _a.pageIndex,\n    plugins = _a.plugins,\n    rotation = _a.rotation,\n    scale = _a.scale,\n    onExecuteNamedAction = _a.onExecuteNamedAction,\n    onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation,\n    onJumpToDest = _a.onJumpToDest;\n  var renderAnnotations = function (annotations) {\n    return React__namespace.createElement(AnnotationLayerBody, {\n      annotations: annotations,\n      doc: doc,\n      outlines: outlines,\n      page: page,\n      pageIndex: pageIndex,\n      plugins: plugins,\n      rotation: rotation,\n      scale: scale,\n      onExecuteNamedAction: onExecuteNamedAction,\n      onJumpFromLinkAnnotation: onJumpFromLinkAnnotation,\n      onJumpToDest: onJumpToDest\n    });\n  };\n  return React__namespace.createElement(AnnotationLoader, {\n    page: page,\n    renderAnnotations: renderAnnotations\n  });\n};\nvar floatToRatio = function (x, limit) {\n  var _a, _b;\n  if (Math.floor(x) === x) {\n    return [x, 1];\n  }\n  var y = 1 / x;\n  if (y > limit) {\n    return [1, limit];\n  }\n  if (Math.floor(y) === y) {\n    return [1, y];\n  }\n  var value = x > 1 ? y : x;\n  var a = 0;\n  var b = 1;\n  var c = 1;\n  var d = 1;\n  while (true) {\n    var numerator = a + c;\n    var denominator = b + d;\n    if (denominator > limit) {\n      break;\n    }\n    value <= numerator / denominator ? (_a = [numerator, denominator], c = _a[0], d = _a[1], _a) : (_b = [numerator, denominator], a = _b[0], b = _b[1], _b);\n  }\n  var middle = (a / b + c / d) / 2;\n  return value < middle ? value === x ? [a, b] : [b, a] : value === x ? [c, d] : [d, c];\n};\nvar roundToDivide = function (a, b) {\n  var remainder = a % b;\n  return remainder === 0 ? a : Math.floor(a - remainder);\n};\nvar MAX_CANVAS_SIZE = 4096 * 4096;\nvar CanvasLayer = function (_a) {\n  var canvasLayerRef = _a.canvasLayerRef,\n    height = _a.height,\n    page = _a.page,\n    pageIndex = _a.pageIndex,\n    plugins = _a.plugins,\n    rotation = _a.rotation,\n    scale = _a.scale,\n    width = _a.width,\n    onRenderCanvasCompleted = _a.onRenderCanvasCompleted;\n  var renderTask = React__namespace.useRef();\n  useIsomorphicLayoutEffect(function () {\n    var task = renderTask.current;\n    if (task) {\n      task.cancel();\n    }\n    var canvasEle = canvasLayerRef.current;\n    canvasEle.removeAttribute('data-testid');\n    plugins.forEach(function (plugin) {\n      if (plugin.onCanvasLayerRender) {\n        plugin.onCanvasLayerRender({\n          ele: canvasEle,\n          pageIndex: pageIndex,\n          rotation: rotation,\n          scale: scale,\n          status: exports.LayerRenderStatus.PreRender\n        });\n      }\n    });\n    var viewport = page.getViewport({\n      rotation: rotation,\n      scale: scale\n    });\n    var outputScale = window.devicePixelRatio || 1;\n    var maxScale = Math.sqrt(MAX_CANVAS_SIZE / (viewport.width * viewport.height));\n    var shouldScaleByCSS = outputScale > maxScale;\n    shouldScaleByCSS ? canvasEle.style.transform = \"scale(1, 1)\" : canvasEle.style.removeProperty('transform');\n    var possibleScale = Math.min(maxScale, outputScale);\n    var _a = floatToRatio(possibleScale, 8),\n      x = _a[0],\n      y = _a[1];\n    canvasEle.width = roundToDivide(viewport.width * possibleScale, x);\n    canvasEle.height = roundToDivide(viewport.height * possibleScale, x);\n    canvasEle.style.width = \"\".concat(roundToDivide(viewport.width, y), \"px\");\n    canvasEle.style.height = \"\".concat(roundToDivide(viewport.height, y), \"px\");\n    canvasEle.hidden = true;\n    var canvasContext = canvasEle.getContext('2d', {\n      alpha: false\n    });\n    var transform = shouldScaleByCSS || outputScale !== 1 ? [possibleScale, 0, 0, possibleScale, 0, 0] : null;\n    renderTask.current = page.render({\n      canvasContext: canvasContext,\n      transform: transform,\n      viewport: viewport\n    });\n    renderTask.current.promise.then(function () {\n      canvasEle.hidden = false;\n      canvasEle.setAttribute('data-testid', \"core__canvas-layer-\".concat(pageIndex));\n      plugins.forEach(function (plugin) {\n        if (plugin.onCanvasLayerRender) {\n          plugin.onCanvasLayerRender({\n            ele: canvasEle,\n            pageIndex: pageIndex,\n            rotation: rotation,\n            scale: scale,\n            status: exports.LayerRenderStatus.DidRender\n          });\n        }\n      });\n      onRenderCanvasCompleted();\n    }, function () {\n      onRenderCanvasCompleted();\n    });\n    return function () {\n      if (canvasEle) {\n        canvasEle.width = 0;\n        canvasEle.height = 0;\n      }\n    };\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    className: \"rpv-core__canvas-layer\",\n    style: {\n      height: \"\".concat(height, \"px\"),\n      width: \"\".concat(width, \"px\")\n    }\n  }, React__namespace.createElement(\"canvas\", {\n    ref: canvasLayerRef\n  }));\n};\nvar SvgLayer = function (_a) {\n  var height = _a.height,\n    page = _a.page,\n    rotation = _a.rotation,\n    scale = _a.scale,\n    width = _a.width;\n  var containerRef = React__namespace.useRef();\n  var empty = function () {\n    var containerEle = containerRef.current;\n    if (!containerEle) {\n      return;\n    }\n    containerEle.innerHTML = '';\n  };\n  useIsomorphicLayoutEffect(function () {\n    var containerEle = containerRef.current;\n    var viewport = page.getViewport({\n      rotation: rotation,\n      scale: scale\n    });\n    page.getOperatorList().then(function (operatorList) {\n      empty();\n      var graphic = new PdfJsApi__namespace.SVGGraphics(page.commonObjs, page.objs);\n      graphic.getSVG(operatorList, viewport).then(function (svg) {\n        svg.style.height = \"\".concat(height, \"px\");\n        svg.style.width = \"\".concat(width, \"px\");\n        containerEle.appendChild(svg);\n      });\n    });\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    className: \"rpv-core__svg-layer\",\n    ref: containerRef\n  });\n};\nvar TextLayer = function (_a) {\n  var containerRef = _a.containerRef,\n    page = _a.page,\n    pageIndex = _a.pageIndex,\n    plugins = _a.plugins,\n    rotation = _a.rotation,\n    scale = _a.scale,\n    onRenderTextCompleted = _a.onRenderTextCompleted;\n  var renderTask = React__namespace.useRef();\n  var empty = function () {\n    var containerEle = containerRef.current;\n    if (!containerEle) {\n      return;\n    }\n    var spans = [].slice.call(containerEle.querySelectorAll('.rpv-core__text-layer-text'));\n    spans.forEach(function (span) {\n      return containerEle.removeChild(span);\n    });\n    var breaks = [].slice.call(containerEle.querySelectorAll('br[role=\"presentation\"]'));\n    breaks.forEach(function (br) {\n      return containerEle.removeChild(br);\n    });\n  };\n  useIsomorphicLayoutEffect(function () {\n    var task = renderTask.current;\n    if (task) {\n      task.cancel();\n    }\n    var containerEle = containerRef.current;\n    if (!containerEle) {\n      return;\n    }\n    containerEle.removeAttribute('data-testid');\n    var viewport = page.getViewport({\n      rotation: rotation,\n      scale: scale\n    });\n    plugins.forEach(function (plugin) {\n      if (plugin.onTextLayerRender) {\n        plugin.onTextLayerRender({\n          ele: containerEle,\n          pageIndex: pageIndex,\n          scale: scale,\n          status: exports.LayerRenderStatus.PreRender\n        });\n      }\n    });\n    page.getTextContent().then(function (textContent) {\n      empty();\n      renderTask.current = PdfJsApi__namespace.renderTextLayer({\n        container: containerEle,\n        textContent: textContent,\n        textContentSource: textContent,\n        viewport: viewport\n      });\n      renderTask.current.promise.then(function () {\n        containerEle.setAttribute('data-testid', \"core__text-layer-\".concat(pageIndex));\n        var spans = [].slice.call(containerEle.children);\n        spans.forEach(function (span) {\n          if (!span.classList.contains('rpv-core__text-layer-text--not')) {\n            span.classList.add('rpv-core__text-layer-text');\n          }\n        });\n        plugins.forEach(function (plugin) {\n          if (plugin.onTextLayerRender) {\n            plugin.onTextLayerRender({\n              ele: containerEle,\n              pageIndex: pageIndex,\n              scale: scale,\n              status: exports.LayerRenderStatus.DidRender\n            });\n          }\n        });\n        onRenderTextCompleted();\n      }, function () {\n        containerEle.removeAttribute('data-testid');\n        onRenderTextCompleted();\n      });\n    });\n    return function () {\n      var _a;\n      empty();\n      (_a = renderTask.current) === null || _a === void 0 ? void 0 : _a.cancel();\n    };\n  }, []);\n  return React__namespace.createElement(\"div\", {\n    className: \"rpv-core__text-layer\",\n    ref: containerRef\n  });\n};\nvar PageLayer = function (_a) {\n  var doc = _a.doc,\n    measureRef = _a.measureRef,\n    outlines = _a.outlines,\n    pageIndex = _a.pageIndex,\n    pageRotation = _a.pageRotation,\n    pageSize = _a.pageSize,\n    plugins = _a.plugins,\n    renderPage = _a.renderPage,\n    renderQueueKey = _a.renderQueueKey,\n    rotation = _a.rotation,\n    scale = _a.scale,\n    shouldRender = _a.shouldRender,\n    viewMode = _a.viewMode,\n    onExecuteNamedAction = _a.onExecuteNamedAction,\n    onJumpFromLinkAnnotation = _a.onJumpFromLinkAnnotation,\n    onJumpToDest = _a.onJumpToDest,\n    onRenderCompleted = _a.onRenderCompleted,\n    onRotatePage = _a.onRotatePage;\n  var isMounted = useIsMounted();\n  var _b = React__namespace.useState(null),\n    page = _b[0],\n    setPage = _b[1];\n  var _c = React__namespace.useState(false),\n    canvasLayerRendered = _c[0],\n    setCanvasLayerRendered = _c[1];\n  var _d = React__namespace.useState(false),\n    textLayerRendered = _d[0],\n    setTextLayerRendered = _d[1];\n  var canvasLayerRef = React__namespace.useRef();\n  var textLayerRef = React__namespace.useRef();\n  var isVertical = Math.abs(rotation + pageRotation) % 180 === 0;\n  var scaledWidth = pageSize.pageWidth * scale;\n  var scaledHeight = pageSize.pageHeight * scale;\n  var w = isVertical ? scaledWidth : scaledHeight;\n  var h = isVertical ? scaledHeight : scaledWidth;\n  var rotationValue = (pageSize.rotation + rotation + pageRotation) % 360;\n  var renderQueueKeyRef = React__namespace.useRef(0);\n  var determinePageInstance = function () {\n    getPage(doc, pageIndex).then(function (pdfPage) {\n      if (isMounted.current) {\n        renderQueueKeyRef.current = renderQueueKey;\n        setPage(pdfPage);\n      }\n    });\n  };\n  var defaultPageRenderer = function (props) {\n    return React__namespace.createElement(React__namespace.Fragment, null, props.canvasLayer.children, props.textLayer.children, props.annotationLayer.children);\n  };\n  var renderPageLayer = renderPage || defaultPageRenderer;\n  var handleRenderCanvasCompleted = function () {\n    if (isMounted.current) {\n      setCanvasLayerRendered(true);\n    }\n  };\n  var handleRenderTextCompleted = function () {\n    if (isMounted.current) {\n      setTextLayerRendered(true);\n    }\n  };\n  React__namespace.useEffect(function () {\n    setPage(null);\n    setCanvasLayerRendered(false);\n    setTextLayerRendered(false);\n  }, [pageRotation, rotation, scale]);\n  React__namespace.useEffect(function () {\n    if (shouldRender && isMounted.current && !page) {\n      determinePageInstance();\n    }\n  }, [shouldRender, page]);\n  React__namespace.useEffect(function () {\n    if (canvasLayerRendered && textLayerRendered) {\n      if (renderQueueKey !== renderQueueKeyRef.current) {\n        setPage(null);\n        setCanvasLayerRendered(false);\n        setTextLayerRendered(false);\n      } else {\n        onRenderCompleted(pageIndex);\n      }\n    }\n  }, [canvasLayerRendered, textLayerRendered]);\n  return React__namespace.createElement(\"div\", {\n    className: classNames({\n      'rpv-core__page-layer': true,\n      'rpv-core__page-layer--dual': viewMode === exports.ViewMode.DualPage,\n      'rpv-core__page-layer--dual-cover': viewMode === exports.ViewMode.DualPageWithCover,\n      'rpv-core__page-layer--single': viewMode === exports.ViewMode.SinglePage\n    }),\n    \"data-testid\": \"core__page-layer-\".concat(pageIndex),\n    ref: measureRef,\n    style: {\n      height: \"\".concat(h, \"px\"),\n      width: \"\".concat(w, \"px\")\n    }\n  }, !page ? React__namespace.createElement(Spinner, {\n    testId: \"core__page-layer-loading-\".concat(pageIndex)\n  }) : React__namespace.createElement(React__namespace.Fragment, null, renderPageLayer({\n    annotationLayer: {\n      attrs: {},\n      children: React__namespace.createElement(AnnotationLayer, {\n        doc: doc,\n        outlines: outlines,\n        page: page,\n        pageIndex: pageIndex,\n        plugins: plugins,\n        rotation: rotationValue,\n        scale: scale,\n        onExecuteNamedAction: onExecuteNamedAction,\n        onJumpFromLinkAnnotation: onJumpFromLinkAnnotation,\n        onJumpToDest: onJumpToDest\n      })\n    },\n    canvasLayer: {\n      attrs: {},\n      children: React__namespace.createElement(CanvasLayer, {\n        canvasLayerRef: canvasLayerRef,\n        height: h,\n        page: page,\n        pageIndex: pageIndex,\n        plugins: plugins,\n        rotation: rotationValue,\n        scale: scale,\n        width: w,\n        onRenderCanvasCompleted: handleRenderCanvasCompleted\n      })\n    },\n    canvasLayerRendered: canvasLayerRendered,\n    doc: doc,\n    height: h,\n    pageIndex: pageIndex,\n    rotation: rotationValue,\n    scale: scale,\n    svgLayer: {\n      attrs: {},\n      children: React__namespace.createElement(SvgLayer, {\n        height: h,\n        page: page,\n        rotation: rotationValue,\n        scale: scale,\n        width: w\n      })\n    },\n    textLayer: {\n      attrs: {},\n      children: React__namespace.createElement(TextLayer, {\n        containerRef: textLayerRef,\n        page: page,\n        pageIndex: pageIndex,\n        plugins: plugins,\n        rotation: rotationValue,\n        scale: scale,\n        onRenderTextCompleted: handleRenderTextCompleted\n      })\n    },\n    textLayerRendered: textLayerRendered,\n    width: w,\n    markRendered: onRenderCompleted,\n    onRotatePage: function (direction) {\n      return onRotatePage(pageIndex, direction);\n    }\n  }), plugins.map(function (plugin, idx) {\n    return plugin.renderPageLayer ? React__namespace.createElement(React__namespace.Fragment, {\n      key: idx\n    }, plugin.renderPageLayer({\n      canvasLayerRef: canvasLayerRef,\n      canvasLayerRendered: canvasLayerRendered,\n      doc: doc,\n      height: h,\n      pageIndex: pageIndex,\n      rotation: rotationValue,\n      scale: scale,\n      textLayerRef: textLayerRef,\n      textLayerRendered: textLayerRendered,\n      width: w\n    })) : React__namespace.createElement(React__namespace.Fragment, {\n      key: idx\n    });\n  })));\n};\nvar getFileExt = function (url) {\n  var str = url.split(/\\./).pop();\n  return str ? str.toLowerCase() : '';\n};\nvar rectReducer = function (state, action) {\n  var rect = action.rect;\n  return state.height !== rect.height || state.width !== rect.width ? rect : state;\n};\nvar useMeasureRect = function (_a) {\n  var elementRef = _a.elementRef;\n  var _b = React__namespace.useState(elementRef.current),\n    element = _b[0],\n    setElement = _b[1];\n  var initializedRectRef = React__namespace.useRef(false);\n  var _c = React__namespace.useReducer(rectReducer, {\n      height: 0,\n      width: 0\n    }),\n    rect = _c[0],\n    dispatch = _c[1];\n  useIsomorphicLayoutEffect(function () {\n    if (elementRef.current !== element) {\n      setElement(elementRef.current);\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (element && !initializedRectRef.current) {\n      initializedRectRef.current = true;\n      var _a = element.getBoundingClientRect(),\n        height = _a.height,\n        width = _a.width;\n      dispatch({\n        rect: {\n          height: height,\n          width: width\n        }\n      });\n    }\n  }, [element]);\n  React__namespace.useEffect(function () {\n    if (!element) {\n      return;\n    }\n    var tracker = new ResizeObserver(function (entries, __) {\n      entries.forEach(function (entry) {\n        if (entry.target === element) {\n          var _a = entry.contentRect,\n            height = _a.height,\n            width = _a.width;\n          dispatch({\n            rect: {\n              height: height,\n              width: width\n            }\n          });\n        }\n      });\n    });\n    tracker.observe(element);\n    return function () {\n      tracker.unobserve(element);\n    };\n  }, [element]);\n  return rect;\n};\nvar ScrollDirection;\n(function (ScrollDirection) {\n  ScrollDirection[\"Horizontal\"] = \"Horizontal\";\n  ScrollDirection[\"Vertical\"] = \"Vertical\";\n  ScrollDirection[\"Both\"] = \"Both\";\n})(ScrollDirection || (ScrollDirection = {}));\nvar easeOutQuart = function (t) {\n  return 1 - Math.pow(1 - t, 4);\n};\nvar EPS = 0.0001;\nvar smoothScroll = function (ele, scrollDirection, targetPosition, duration, easing, onReachTarget) {\n  if (easing === void 0) {\n    easing = function (t) {\n      return t;\n    };\n  }\n  if (onReachTarget === void 0) {\n    onReachTarget = function () {};\n  }\n  var top = 0;\n  var left = 0;\n  var reachTarget = false;\n  switch (scrollDirection) {\n    case ScrollDirection.Horizontal:\n      left = ele.scrollLeft;\n      top = 0;\n    case ScrollDirection.Both:\n      left = ele.scrollLeft;\n      top = ele.scrollTop;\n      break;\n    case ScrollDirection.Vertical:\n    default:\n      left = 0;\n      top = ele.scrollTop;\n      break;\n  }\n  var markTargetReached = function () {\n    if (!reachTarget) {\n      reachTarget = true;\n      ele.scrollLeft = targetPosition.left;\n      ele.scrollTop = targetPosition.top;\n      onReachTarget();\n    }\n  };\n  if (Math.abs(top - targetPosition.top) <= EPS && scrollDirection === ScrollDirection.Vertical) {\n    markTargetReached();\n    return;\n  }\n  if (Math.abs(left - targetPosition.left) <= EPS && scrollDirection === ScrollDirection.Horizontal) {\n    markTargetReached();\n    return;\n  }\n  var startTime = -1;\n  var requestId;\n  var offset = {\n    left: left - targetPosition.left,\n    top: top - targetPosition.top\n  };\n  var loop = function (currentTime) {\n    if (startTime === -1) {\n      startTime = currentTime;\n    }\n    var time = currentTime - startTime;\n    var percent = Math.min(time / duration, 1);\n    var easedPercent = easing(percent);\n    var updatePosition = {\n      left: left - offset.left * easedPercent,\n      top: top - offset.top * easedPercent\n    };\n    switch (scrollDirection) {\n      case ScrollDirection.Horizontal:\n        ele.scrollLeft = updatePosition.left;\n        break;\n      case ScrollDirection.Both:\n        ele.scrollLeft = updatePosition.left;\n        ele.scrollTop = updatePosition.top;\n        break;\n      case ScrollDirection.Vertical:\n      default:\n        ele.scrollTop = updatePosition.top;\n        break;\n    }\n    if (Math.abs(updatePosition.top - targetPosition.top) <= EPS && Math.abs(updatePosition.left - targetPosition.left) <= EPS && !reachTarget) {\n      window.cancelAnimationFrame(requestId);\n      markTargetReached();\n    }\n    if (time < duration) {\n      requestId = window.requestAnimationFrame(loop);\n    } else {\n      window.cancelAnimationFrame(requestId);\n    }\n  };\n  requestId = window.requestAnimationFrame(loop);\n};\nvar ZERO_OFFSET$6 = {\n  left: 0,\n  top: 0\n};\nvar SCROLL_EVENT_OPTIONS = {\n  capture: false,\n  passive: true\n};\nvar SCROLL_DURATION = 400;\nvar useScroll = function (_a) {\n  var elementRef = _a.elementRef,\n    enableSmoothScroll = _a.enableSmoothScroll,\n    isRtl = _a.isRtl,\n    scrollDirection = _a.scrollDirection,\n    onSmoothScroll = _a.onSmoothScroll;\n  var _b = React__namespace.useState(ZERO_OFFSET$6),\n    scrollOffset = _b[0],\n    setScrollOffset = _b[1];\n  var _c = React__namespace.useState(elementRef.current),\n    element = _c[0],\n    setElement = _c[1];\n  var factor = isRtl ? -1 : 1;\n  var latestRef = React__namespace.useRef(scrollDirection);\n  latestRef.current = scrollDirection;\n  var latestOffsetRef = React__namespace.useRef(ZERO_OFFSET$6);\n  var isSmoothScrollingDoneRef = React__namespace.useRef(true);\n  var handleSmoothScrollingComplete = React__namespace.useCallback(function () {\n    isSmoothScrollingDoneRef.current = true;\n    if (enableSmoothScroll) {\n      setScrollOffset(latestOffsetRef.current);\n    }\n    onSmoothScroll(false);\n  }, []);\n  var handleScroll = React__namespace.useCallback(function () {\n    if (!element) {\n      return;\n    }\n    switch (latestRef.current) {\n      case ScrollDirection.Horizontal:\n        latestOffsetRef.current = {\n          left: factor * element.scrollLeft,\n          top: 0\n        };\n        break;\n      case ScrollDirection.Both:\n        latestOffsetRef.current = {\n          left: factor * element.scrollLeft,\n          top: element.scrollTop\n        };\n        break;\n      case ScrollDirection.Vertical:\n      default:\n        latestOffsetRef.current = {\n          left: 0,\n          top: element.scrollTop\n        };\n        break;\n    }\n    if (!enableSmoothScroll || isSmoothScrollingDoneRef.current) {\n      setScrollOffset(latestOffsetRef.current);\n    }\n  }, [element]);\n  useIsomorphicLayoutEffect(function () {\n    setElement(elementRef.current);\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (!element) {\n      return;\n    }\n    element.addEventListener('scroll', handleScroll, SCROLL_EVENT_OPTIONS);\n    return function () {\n      element.removeEventListener('scroll', handleScroll, SCROLL_EVENT_OPTIONS);\n    };\n  }, [element]);\n  var scrollTo = React__namespace.useCallback(function (targetPosition, withSmoothScroll) {\n    var ele = elementRef.current;\n    if (!ele) {\n      return Promise.resolve();\n    }\n    var updatePosition = {\n      left: 0,\n      top: 0\n    };\n    switch (latestRef.current) {\n      case ScrollDirection.Horizontal:\n        updatePosition.left = factor * targetPosition.left;\n        break;\n      case ScrollDirection.Both:\n        updatePosition.left = factor * targetPosition.left;\n        updatePosition.top = targetPosition.top;\n        break;\n      case ScrollDirection.Vertical:\n      default:\n        updatePosition.top = targetPosition.top;\n        break;\n    }\n    if (withSmoothScroll) {\n      isSmoothScrollingDoneRef.current = false;\n      onSmoothScroll(true);\n      return new Promise(function (resolve, _) {\n        smoothScroll(ele, latestRef.current, updatePosition, SCROLL_DURATION, easeOutQuart, function () {\n          handleSmoothScrollingComplete();\n          resolve();\n        });\n      });\n    }\n    return new Promise(function (resolve, _) {\n      switch (latestRef.current) {\n        case ScrollDirection.Horizontal:\n          ele.scrollLeft = updatePosition.left;\n          break;\n        case ScrollDirection.Both:\n          ele.scrollLeft = updatePosition.left;\n          ele.scrollTop = updatePosition.top;\n          break;\n        case ScrollDirection.Vertical:\n        default:\n          ele.scrollTop = updatePosition.top;\n          break;\n      }\n      resolve();\n    });\n  }, [elementRef]);\n  return {\n    scrollOffset: scrollOffset,\n    scrollTo: scrollTo\n  };\n};\nvar clamp = function (min, max, value) {\n  return Math.max(min, Math.min(value, max));\n};\nvar indexOfMax = function (arr) {\n  return arr.reduce(function (prev, curr, i, a) {\n    return curr > a[prev] ? i : prev;\n  }, 0);\n};\nvar buildContainerStyles = function (totalSize, scrollMode) {\n  switch (scrollMode) {\n    case exports.ScrollMode.Horizontal:\n      return {\n        position: 'relative',\n        height: '100%',\n        width: \"\".concat(totalSize.width, \"px\")\n      };\n    case exports.ScrollMode.Vertical:\n    default:\n      return {\n        position: 'relative',\n        height: \"\".concat(totalSize.height, \"px\"),\n        width: '100%'\n      };\n  }\n};\nvar buildItemContainerStyles = function (item, parentRect, scrollMode) {\n  return scrollMode !== exports.ScrollMode.Page ? {} : {\n    height: \"\".concat(parentRect.height, \"px\"),\n    width: '100%',\n    position: 'absolute',\n    top: 0,\n    transform: \"translateY(\".concat(item.start.top, \"px)\")\n  };\n};\nvar hasDifferentSizes = function (sizes) {\n  var numberOfItems = sizes.length;\n  if (numberOfItems === 1) {\n    return false;\n  }\n  for (var i = 1; i < numberOfItems; i++) {\n    if (sizes[i].height !== sizes[0].height || sizes[i].width !== sizes[0].width) {\n      return true;\n    }\n  }\n  return false;\n};\nvar getMinWidthOfCover = function (sizes, viewMode) {\n  if (viewMode !== exports.ViewMode.DualPageWithCover) {\n    return 0;\n  }\n  if (!hasDifferentSizes(sizes)) {\n    return 2 * sizes[0].width;\n  }\n  var chunkWidths = chunk(sizes.slice(1), 2).map(function (eachChunk) {\n    return eachChunk.length === 2 ? eachChunk[0].width + eachChunk[1].width : eachChunk[0].width;\n  });\n  var widths = [sizes[0].width].concat(chunkWidths);\n  return Math.max.apply(Math, widths);\n};\nvar buildItemStyles = function (item, isRtl, sizes, viewMode, scrollMode) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  var sideProperty = isRtl ? 'right' : 'left';\n  var factor = isRtl ? -1 : 1;\n  var numberOfItems = sizes.length;\n  var left = item.start.left * factor;\n  var _h = item.size,\n    height = _h.height,\n    width = _h.width;\n  if (viewMode === exports.ViewMode.DualPageWithCover) {\n    var transformTop = scrollMode === exports.ScrollMode.Page ? 0 : item.start.top;\n    if (item.index === 0 || numberOfItems % 2 === 0 && item.index === numberOfItems - 1) {\n      return _a = {\n        height: \"\".concat(height, \"px\"),\n        minWidth: \"\".concat(getMinWidthOfCover(sizes, viewMode), \"px\"),\n        width: '100%'\n      }, _a[sideProperty] = 0, _a.position = 'absolute', _a.top = 0, _a.transform = \"translate(\".concat(left, \"px, \").concat(transformTop, \"px)\"), _a;\n    }\n    return _b = {\n      height: \"\".concat(height, \"px\"),\n      width: \"\".concat(width, \"px\")\n    }, _b[sideProperty] = 0, _b.position = 'absolute', _b.top = 0, _b.transform = \"translate(\".concat(left, \"px, \").concat(transformTop, \"px)\"), _b;\n  }\n  if (viewMode === exports.ViewMode.DualPage) {\n    return _c = {\n      height: \"\".concat(height, \"px\"),\n      width: \"\".concat(width, \"px\")\n    }, _c[sideProperty] = 0, _c.position = 'absolute', _c.top = 0, _c.transform = \"translate(\".concat(left, \"px, \").concat(scrollMode === exports.ScrollMode.Page ? 0 : item.start.top, \"px)\"), _c;\n  }\n  switch (scrollMode) {\n    case exports.ScrollMode.Horizontal:\n      return _d = {\n        height: '100%',\n        width: \"\".concat(width, \"px\")\n      }, _d[sideProperty] = 0, _d.position = 'absolute', _d.top = 0, _d.transform = \"translateX(\".concat(left, \"px)\"), _d;\n    case exports.ScrollMode.Page:\n      return _e = {\n        height: \"\".concat(height, \"px\"),\n        width: \"\".concat(width, \"px\")\n      }, _e[sideProperty] = 0, _e.position = 'absolute', _e.top = 0, _e;\n    case exports.ScrollMode.Wrapped:\n      return _f = {\n        height: \"\".concat(height, \"px\"),\n        width: \"\".concat(width, \"px\")\n      }, _f[sideProperty] = 0, _f.position = 'absolute', _f.top = 0, _f.transform = \"translate(\".concat(left, \"px, \").concat(item.start.top, \"px)\"), _f;\n    case exports.ScrollMode.Vertical:\n    default:\n      return _g = {\n        height: \"\".concat(height, \"px\"),\n        width: '100%'\n      }, _g[sideProperty] = 0, _g.position = 'absolute', _g.top = 0, _g.transform = \"translateY(\".concat(item.start.top, \"px)\"), _g;\n  }\n};\nvar findNearest = function (low, high, value, getItemValue) {\n  while (low <= high) {\n    var middle = (low + high) / 2 | 0;\n    var currentValue = getItemValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  return low > 0 ? low - 1 : 0;\n};\nvar calculateRange = function (scrollDirection, measurements, outerSize, scrollOffset) {\n  var currentOffset = 0;\n  switch (scrollDirection) {\n    case ScrollDirection.Horizontal:\n      currentOffset = scrollOffset.left;\n      break;\n    case ScrollDirection.Vertical:\n    default:\n      currentOffset = scrollOffset.top;\n      break;\n  }\n  var size = measurements.length - 1;\n  var getOffset = function (index) {\n    switch (scrollDirection) {\n      case ScrollDirection.Horizontal:\n        return measurements[index].start.left;\n      case ScrollDirection.Both:\n      case ScrollDirection.Vertical:\n      default:\n        return measurements[index].start.top;\n    }\n  };\n  var start = findNearest(0, size, currentOffset, getOffset);\n  if (scrollDirection === ScrollDirection.Both) {\n    var startTop = measurements[start].start.top;\n    while (start - 1 >= 0 && measurements[start - 1].start.top === startTop && measurements[start - 1].start.left >= scrollOffset.left) {\n      start--;\n    }\n  }\n  var end = start;\n  while (end <= size) {\n    var topLeftCorner = {\n      top: measurements[end].start.top - scrollOffset.top,\n      left: measurements[end].start.left - scrollOffset.left\n    };\n    var visibleSize = {\n      height: outerSize.height - topLeftCorner.top,\n      width: outerSize.width - topLeftCorner.left\n    };\n    if (scrollDirection === ScrollDirection.Horizontal && visibleSize.width < 0) {\n      break;\n    }\n    if (scrollDirection === ScrollDirection.Vertical && visibleSize.height < 0) {\n      break;\n    }\n    if (scrollDirection === ScrollDirection.Both && (visibleSize.width < 0 || visibleSize.height < 0)) {\n      break;\n    }\n    end++;\n  }\n  return {\n    start: start,\n    end: end\n  };\n};\nvar ZERO_OFFSET$5 = {\n  left: 0,\n  top: 0\n};\nvar measure = function (numberOfItems, parentRect, sizes, scrollMode) {\n  var measurements = [];\n  var totalWidth = 0;\n  var firstOfRow = {\n    left: 0,\n    top: 0\n  };\n  var maxHeight = 0;\n  var start = ZERO_OFFSET$5;\n  for (var i = 0; i < numberOfItems; i++) {\n    var size = sizes[i];\n    if (i === 0) {\n      totalWidth = size.width;\n      firstOfRow = {\n        left: 0,\n        top: 0\n      };\n      maxHeight = size.height;\n    } else {\n      switch (scrollMode) {\n        case exports.ScrollMode.Wrapped:\n          totalWidth += size.width;\n          if (totalWidth < parentRect.width) {\n            start = {\n              left: measurements[i - 1].end.left,\n              top: firstOfRow.top\n            };\n            maxHeight = Math.max(maxHeight, size.height);\n          } else {\n            totalWidth = size.width;\n            start = {\n              left: firstOfRow.left,\n              top: firstOfRow.top + maxHeight\n            };\n            firstOfRow = {\n              left: start.left,\n              top: start.top\n            };\n            maxHeight = size.height;\n          }\n          break;\n        case exports.ScrollMode.Horizontal:\n        case exports.ScrollMode.Vertical:\n        default:\n          start = measurements[i - 1].end;\n          break;\n      }\n    }\n    var end = {\n      left: start.left + size.width,\n      top: start.top + size.height\n    };\n    measurements[i] = {\n      index: i,\n      start: start,\n      size: size,\n      end: end,\n      visibility: -1\n    };\n  }\n  return measurements;\n};\nvar ZERO_OFFSET$4 = {\n  left: 0,\n  top: 0\n};\nvar measureDualPage = function (numberOfItems, parentRect, sizes, scrollMode) {\n  var measurements = [];\n  var top = 0;\n  var maxHeight = 0;\n  var start = ZERO_OFFSET$4;\n  for (var i = 0; i < numberOfItems; i++) {\n    var size = {\n      height: scrollMode === exports.ScrollMode.Page ? Math.max(parentRect.height, sizes[i].height) : sizes[i].height,\n      width: Math.max(parentRect.width / 2, sizes[i].width)\n    };\n    if (scrollMode === exports.ScrollMode.Page) {\n      start = {\n        left: i % 2 === 0 ? 0 : size.width,\n        top: Math.floor(i / 2) * size.height\n      };\n    } else {\n      if (i % 2 === 0) {\n        top = top + maxHeight;\n        start = {\n          left: 0,\n          top: top\n        };\n        maxHeight = i === numberOfItems - 1 ? sizes[i].height : Math.max(sizes[i].height, sizes[i + 1].height);\n      } else {\n        start = {\n          left: measurements[i - 1].end.left,\n          top: top\n        };\n      }\n    }\n    var end = {\n      left: start.left + size.width,\n      top: start.top + size.height\n    };\n    measurements[i] = {\n      index: i,\n      start: start,\n      size: size,\n      end: end,\n      visibility: -1\n    };\n  }\n  return measurements;\n};\nvar ZERO_OFFSET$3 = {\n  left: 0,\n  top: 0\n};\nvar measureDualPageWithCover = function (numberOfItems, parentRect, sizes, scrollMode) {\n  var measurements = [];\n  var top = 0;\n  var maxHeight = 0;\n  var start = ZERO_OFFSET$3;\n  for (var i = 0; i < numberOfItems; i++) {\n    var size = i === 0 ? {\n      height: scrollMode === exports.ScrollMode.Page ? Math.max(parentRect.height, sizes[i].height) : sizes[i].height,\n      width: scrollMode === exports.ScrollMode.Page ? Math.max(parentRect.width, sizes[i].width) : sizes[i].width\n    } : {\n      height: scrollMode === exports.ScrollMode.Page ? Math.max(parentRect.height, sizes[i].height) : sizes[i].height,\n      width: Math.max(parentRect.width / 2, sizes[i].width)\n    };\n    if (scrollMode === exports.ScrollMode.Page) {\n      start = i === 0 ? ZERO_OFFSET$3 : {\n        left: i % 2 === 0 ? size.width : 0,\n        top: Math.floor((i - 1) / 2) * size.height + measurements[0].end.top\n      };\n    } else {\n      if (i === 0) {\n        start = ZERO_OFFSET$3;\n        top = sizes[0].height;\n        maxHeight = 0;\n      } else if (i % 2 === 1) {\n        top = top + maxHeight;\n        start = {\n          left: 0,\n          top: top\n        };\n        maxHeight = i === numberOfItems - 1 ? sizes[i].height : Math.max(sizes[i].height, sizes[i + 1].height);\n      } else {\n        start = {\n          left: measurements[i - 1].end.left,\n          top: top\n        };\n      }\n    }\n    var end = {\n      left: start.left + size.width,\n      top: start.top + size.height\n    };\n    measurements[i] = {\n      index: i,\n      start: start,\n      size: size,\n      end: end,\n      visibility: -1\n    };\n  }\n  return measurements;\n};\nvar ZERO_OFFSET$2 = {\n  left: 0,\n  top: 0\n};\nvar measureSinglePage = function (numberOfItems, parentRect, sizes) {\n  var measurements = [];\n  for (var i = 0; i < numberOfItems; i++) {\n    var size = {\n      height: Math.max(parentRect.height, sizes[i].height),\n      width: Math.max(parentRect.width, sizes[i].width)\n    };\n    var start = i === 0 ? ZERO_OFFSET$2 : measurements[i - 1].end;\n    var end = {\n      left: start.left + size.width,\n      top: start.top + size.height\n    };\n    measurements[i] = {\n      index: i,\n      start: start,\n      size: size,\n      end: end,\n      visibility: -1\n    };\n  }\n  return measurements;\n};\nvar ZERO_RECT$2 = {\n  height: 0,\n  width: 0\n};\nvar ZERO_OFFSET$1 = {\n  left: 0,\n  top: 0\n};\nvar COMPARE_EPSILON = 0.000000000001;\nvar VIRTUAL_INDEX_ATTR = 'data-virtual-index';\nvar IO_THRESHOLD = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1];\nvar useVirtual = function (_a) {\n  var enableSmoothScroll = _a.enableSmoothScroll,\n    isRtl = _a.isRtl,\n    numberOfItems = _a.numberOfItems,\n    parentRef = _a.parentRef,\n    setRenderRange = _a.setRenderRange,\n    sizes = _a.sizes,\n    scrollMode = _a.scrollMode,\n    viewMode = _a.viewMode;\n  var _b = React__namespace.useState(false),\n    isSmoothScrolling = _b[0],\n    setSmoothScrolling = _b[1];\n  var onSmoothScroll = React__namespace.useCallback(function (isSmoothScrolling) {\n    return setSmoothScrolling(isSmoothScrolling);\n  }, []);\n  var scrollModeRef = React__namespace.useRef(scrollMode);\n  scrollModeRef.current = scrollMode;\n  var viewModeRef = React__namespace.useRef(viewMode);\n  viewModeRef.current = viewMode;\n  var scrollDirection = scrollMode === exports.ScrollMode.Wrapped || viewMode === exports.ViewMode.DualPageWithCover || viewMode === exports.ViewMode.DualPage ? ScrollDirection.Both : scrollMode === exports.ScrollMode.Horizontal ? ScrollDirection.Horizontal : ScrollDirection.Vertical;\n  var _c = useScroll({\n      elementRef: parentRef,\n      enableSmoothScroll: enableSmoothScroll,\n      isRtl: isRtl,\n      scrollDirection: scrollDirection,\n      onSmoothScroll: onSmoothScroll\n    }),\n    scrollOffset = _c.scrollOffset,\n    scrollTo = _c.scrollTo;\n  var parentRect = useMeasureRect({\n    elementRef: parentRef\n  });\n  var latestRef = React__namespace.useRef({\n    scrollOffset: ZERO_OFFSET$1,\n    measurements: []\n  });\n  latestRef.current.scrollOffset = scrollOffset;\n  var defaultVisibilities = React__namespace.useMemo(function () {\n    return Array(numberOfItems).fill(-1);\n  }, []);\n  var _d = React__namespace.useState(defaultVisibilities),\n    visibilities = _d[0],\n    setVisibilities = _d[1];\n  var intersectionTracker = React__namespace.useMemo(function () {\n    var io = new IntersectionObserver(function (entries) {\n      entries.forEach(function (entry) {\n        var ratio = entry.isIntersecting ? entry.intersectionRatio : -1;\n        var target = entry.target;\n        var indexAttribute = target.getAttribute(VIRTUAL_INDEX_ATTR);\n        if (!indexAttribute) {\n          return;\n        }\n        var index = parseInt(indexAttribute, 10);\n        if (0 <= index && index < numberOfItems) {\n          setVisibilities(function (old) {\n            old[index] = ratio;\n            return __spreadArray([], old, true);\n          });\n        }\n      });\n    }, {\n      threshold: IO_THRESHOLD\n    });\n    return io;\n  }, []);\n  var measurements = React__namespace.useMemo(function () {\n    if (scrollMode === exports.ScrollMode.Page && viewMode === exports.ViewMode.SinglePage) {\n      return measureSinglePage(numberOfItems, parentRect, sizes);\n    }\n    if (viewMode === exports.ViewMode.DualPageWithCover) {\n      return measureDualPageWithCover(numberOfItems, parentRect, sizes, scrollMode);\n    }\n    if (viewMode === exports.ViewMode.DualPage) {\n      return measureDualPage(numberOfItems, parentRect, sizes, scrollMode);\n    }\n    return measure(numberOfItems, parentRect, sizes, scrollMode);\n  }, [scrollMode, sizes, viewMode, parentRect]);\n  var totalSize = measurements[numberOfItems - 1] ? {\n    height: measurements[numberOfItems - 1].end.top,\n    width: measurements[numberOfItems - 1].end.left\n  } : ZERO_RECT$2;\n  latestRef.current.measurements = measurements;\n  var _e = React__namespace.useMemo(function () {\n      var _a = calculateRange(scrollDirection, measurements, parentRect, scrollOffset),\n        start = _a.start,\n        end = _a.end;\n      var visiblePageVisibilities = visibilities.slice(clamp(0, numberOfItems, start), clamp(0, numberOfItems, end));\n      var maxVisbilityItem = start + indexOfMax(visiblePageVisibilities);\n      maxVisbilityItem = clamp(0, numberOfItems - 1, maxVisbilityItem);\n      var maxVisbilityIndex = maxVisbilityItem;\n      var _b = setRenderRange({\n          endPage: end,\n          numPages: numberOfItems,\n          startPage: start\n        }),\n        startPage = _b.startPage,\n        endPage = _b.endPage;\n      startPage = Math.max(startPage, 0);\n      endPage = Math.min(endPage, numberOfItems - 1);\n      switch (viewMode) {\n        case exports.ViewMode.DualPageWithCover:\n          if (maxVisbilityItem > 0) {\n            maxVisbilityIndex = maxVisbilityItem % 2 === 1 ? maxVisbilityItem : maxVisbilityItem - 1;\n          }\n          startPage = startPage === 0 ? 0 : startPage % 2 === 1 ? startPage : startPage - 1;\n          endPage = endPage % 2 === 1 ? endPage - 1 : endPage;\n          if (numberOfItems - endPage <= 2) {\n            endPage = numberOfItems - 1;\n          }\n          break;\n        case exports.ViewMode.DualPage:\n          maxVisbilityIndex = maxVisbilityItem % 2 === 0 ? maxVisbilityItem : maxVisbilityItem - 1;\n          startPage = startPage % 2 === 0 ? startPage : startPage - 1;\n          endPage = endPage % 2 === 1 ? endPage : endPage - 1;\n          break;\n        case exports.ViewMode.SinglePage:\n        default:\n          maxVisbilityIndex = maxVisbilityItem;\n          break;\n      }\n      return {\n        startPage: startPage,\n        endPage: endPage,\n        maxVisbilityIndex: maxVisbilityIndex\n      };\n    }, [measurements, parentRect, scrollOffset, viewMode, visibilities]),\n    startPage = _e.startPage,\n    endPage = _e.endPage,\n    maxVisbilityIndex = _e.maxVisbilityIndex;\n  var virtualItems = React__namespace.useMemo(function () {\n    var virtualItems = [];\n    var _loop_1 = function (i) {\n      var item = measurements[i];\n      var virtualItem = __assign(__assign({}, item), {\n        visibility: visibilities[i] !== undefined ? visibilities[i] : -1,\n        measureRef: function (ele) {\n          if (!ele) {\n            return;\n          }\n          ele.setAttribute(VIRTUAL_INDEX_ATTR, \"\".concat(i));\n          intersectionTracker.observe(ele);\n        }\n      });\n      virtualItems.push(virtualItem);\n    };\n    for (var i = startPage; i <= endPage; i++) {\n      _loop_1(i);\n    }\n    return virtualItems;\n  }, [startPage, endPage, visibilities, measurements]);\n  var scrollToItem = React__namespace.useCallback(function (index, offset) {\n    var measurements = latestRef.current.measurements;\n    var normalizedIndex = clamp(0, numberOfItems - 1, index);\n    var measurement = measurements[normalizedIndex];\n    var withOffset = scrollModeRef.current === exports.ScrollMode.Page ? ZERO_OFFSET$1 : offset;\n    return measurement ? scrollTo({\n      left: withOffset.left + measurement.start.left,\n      top: withOffset.top + measurement.start.top\n    }, enableSmoothScroll) : Promise.resolve();\n  }, [scrollTo, enableSmoothScroll]);\n  var scrollToSmallestItemAbove = React__namespace.useCallback(function (index, offset) {\n    var measurements = latestRef.current.measurements;\n    var start = measurements[index].start;\n    var nextItem = measurements.find(function (item) {\n      return item.start.top - start.top > COMPARE_EPSILON;\n    });\n    if (!nextItem) {\n      return Promise.resolve();\n    }\n    var nextIndex = nextItem.index;\n    switch (viewModeRef.current) {\n      case exports.ViewMode.DualPage:\n        nextIndex = nextIndex % 2 === 0 ? nextIndex : nextIndex + 1;\n        break;\n      case exports.ViewMode.DualPageWithCover:\n        nextIndex = nextIndex % 2 === 1 ? nextIndex : nextIndex + 1;\n        break;\n    }\n    return scrollToItem(nextIndex, offset);\n  }, []);\n  var scrollToBiggestItemBelow = React__namespace.useCallback(function (index, offset) {\n    var measurements = latestRef.current.measurements;\n    var start = measurements[index].start;\n    var prevIndex = index;\n    var found = false;\n    for (var i = numberOfItems - 1; i >= 0; i--) {\n      if (start.top - measurements[i].start.top > COMPARE_EPSILON) {\n        found = true;\n        prevIndex = measurements[i].index;\n        break;\n      }\n    }\n    if (!found) {\n      return Promise.resolve();\n    }\n    switch (viewModeRef.current) {\n      case exports.ViewMode.DualPage:\n        prevIndex = prevIndex % 2 === 0 ? prevIndex : prevIndex - 1;\n        break;\n      case exports.ViewMode.DualPageWithCover:\n        prevIndex = prevIndex % 2 === 0 ? prevIndex - 1 : prevIndex;\n        break;\n    }\n    if (prevIndex === index) {\n      prevIndex = index - 1;\n    }\n    return scrollToItem(prevIndex, offset);\n  }, []);\n  var scrollToNextItem = React__namespace.useCallback(function (index, offset) {\n    if (viewModeRef.current === exports.ViewMode.DualPageWithCover || viewModeRef.current === exports.ViewMode.DualPage) {\n      return scrollToSmallestItemAbove(index, offset);\n    }\n    switch (scrollModeRef.current) {\n      case exports.ScrollMode.Wrapped:\n        return scrollToSmallestItemAbove(index, offset);\n      case exports.ScrollMode.Horizontal:\n      case exports.ScrollMode.Vertical:\n      default:\n        return scrollToItem(index + 1, offset);\n    }\n  }, []);\n  var scrollToPreviousItem = React__namespace.useCallback(function (index, offset) {\n    if (viewModeRef.current === exports.ViewMode.DualPageWithCover || viewModeRef.current === exports.ViewMode.DualPage) {\n      return scrollToBiggestItemBelow(index, offset);\n    }\n    switch (scrollModeRef.current) {\n      case exports.ScrollMode.Wrapped:\n        return scrollToBiggestItemBelow(index, offset);\n      case exports.ScrollMode.Horizontal:\n      case exports.ScrollMode.Vertical:\n      default:\n        return scrollToItem(index - 1, offset);\n    }\n  }, []);\n  var getContainerStyles = React__namespace.useCallback(function () {\n    return buildContainerStyles(totalSize, scrollModeRef.current);\n  }, [totalSize]);\n  var getItemContainerStyles = React__namespace.useCallback(function (item) {\n    return buildItemContainerStyles(item, parentRect, scrollModeRef.current);\n  }, [parentRect]);\n  var getItemStyles = React__namespace.useCallback(function (item) {\n    return buildItemStyles(item, isRtl, sizes, viewModeRef.current, scrollModeRef.current);\n  }, [isRtl, sizes]);\n  var zoom = React__namespace.useCallback(function (scale, index) {\n    var _a = latestRef.current,\n      measurements = _a.measurements,\n      scrollOffset = _a.scrollOffset;\n    var normalizedIndex = clamp(0, numberOfItems - 1, index);\n    var measurement = measurements[normalizedIndex];\n    if (measurement) {\n      var updateOffset = scrollModeRef.current === exports.ScrollMode.Page ? {\n        left: measurement.start.left,\n        top: measurement.start.top\n      } : {\n        left: scrollOffset.left * scale,\n        top: scrollOffset.top * scale\n      };\n      return scrollTo(updateOffset, false);\n    }\n    return Promise.resolve();\n  }, []);\n  React__namespace.useEffect(function () {\n    return function () {\n      intersectionTracker.disconnect();\n    };\n  }, []);\n  return {\n    boundingClientRect: parentRect,\n    isSmoothScrolling: isSmoothScrolling,\n    startPage: startPage,\n    endPage: endPage,\n    maxVisbilityIndex: maxVisbilityIndex,\n    virtualItems: virtualItems,\n    getContainerStyles: getContainerStyles,\n    getItemContainerStyles: getItemContainerStyles,\n    getItemStyles: getItemStyles,\n    scrollToItem: scrollToItem,\n    scrollToNextItem: scrollToNextItem,\n    scrollToPreviousItem: scrollToPreviousItem,\n    zoom: zoom\n  };\n};\nvar SCROLL_BAR_WIDTH = 17;\nvar PAGE_PADDING = 8;\nvar calculateScale = function (container, pageHeight, pageWidth, scale, viewMode, numPages) {\n  var w = pageWidth;\n  switch (true) {\n    case viewMode === exports.ViewMode.DualPageWithCover && numPages >= 3:\n    case viewMode === exports.ViewMode.DualPage && numPages >= 3:\n      w = 2 * pageWidth;\n      break;\n    default:\n      w = pageWidth;\n      break;\n  }\n  switch (scale) {\n    case exports.SpecialZoomLevel.ActualSize:\n      return 1;\n    case exports.SpecialZoomLevel.PageFit:\n      return Math.min((container.clientWidth - SCROLL_BAR_WIDTH) / w, (container.clientHeight - 2 * PAGE_PADDING) / pageHeight);\n    case exports.SpecialZoomLevel.PageWidth:\n      return (container.clientWidth - SCROLL_BAR_WIDTH) / w;\n  }\n};\nvar useStack = function (maxLength) {\n  var stackRef = React__namespace.useRef([]);\n  var map = function (transformer) {\n    return stackRef.current.map(function (item) {\n      return transformer(item);\n    });\n  };\n  var pop = function () {\n    var stack = stackRef.current;\n    var size = stack.length;\n    if (size === 0) {\n      return null;\n    }\n    var lastItem = stack.pop();\n    stackRef.current = stack;\n    return lastItem;\n  };\n  var push = function (item) {\n    var stack = stackRef.current;\n    if (stack.length + 1 > maxLength) {\n      stack.shift();\n    }\n    stack.push(item);\n    stackRef.current = stack;\n  };\n  React__namespace.useEffect(function () {\n    return function () {\n      stackRef.current = [];\n    };\n  }, []);\n  return {\n    push: push,\n    map: map,\n    pop: pop\n  };\n};\nvar useQueue = function (maxLength) {\n  var queueRef = React__namespace.useRef([]);\n  var dequeue = function () {\n    var queue = queueRef.current;\n    var size = queue.length;\n    if (size === 0) {\n      return null;\n    }\n    var firstItem = queue.shift();\n    queueRef.current = queue;\n    return firstItem || null;\n  };\n  var enqueue = function (item) {\n    var queue = queueRef.current;\n    if (queue.length + 1 > maxLength) {\n      queue.pop();\n    }\n    queueRef.current = [item].concat(queue);\n  };\n  var map = function (transformer) {\n    return queueRef.current.map(function (item) {\n      return transformer(item);\n    });\n  };\n  React__namespace.useEffect(function () {\n    return function () {\n      queueRef.current = [];\n    };\n  }, []);\n  return {\n    dequeue: dequeue,\n    enqueue: enqueue,\n    map: map\n  };\n};\nvar MAX_QUEUE_LENGTH = 50;\nvar useDestination = function (_a) {\n  var getCurrentPage = _a.getCurrentPage;\n  var previousDestinations = useStack(MAX_QUEUE_LENGTH);\n  var nextDestinations = useQueue(MAX_QUEUE_LENGTH);\n  var getNextDestination = function () {\n    var nextDest = nextDestinations.dequeue();\n    if (nextDest) {\n      previousDestinations.push(nextDest);\n    }\n    if (nextDest && nextDest.pageIndex === getCurrentPage()) {\n      return getNextDestination();\n    }\n    return nextDest;\n  };\n  var getPreviousDestination = function () {\n    var prevDest = previousDestinations.pop();\n    if (prevDest) {\n      nextDestinations.enqueue(prevDest);\n    }\n    if (prevDest && prevDest.pageIndex === getCurrentPage()) {\n      return getPreviousDestination();\n    }\n    return prevDest;\n  };\n  var markVisitedDestination = React__namespace.useCallback(function (destination) {\n    previousDestinations.push(destination);\n  }, []);\n  return {\n    getNextDestination: getNextDestination,\n    getPreviousDestination: getPreviousDestination,\n    markVisitedDestination: markVisitedDestination\n  };\n};\nvar flaternSingleOutline = function (outline) {\n  var result = [];\n  if (outline.items && outline.items.length > 0) {\n    result = result.concat(flaternOutlines(outline.items));\n  }\n  return result;\n};\nvar flaternOutlines = function (outlines) {\n  var result = [];\n  outlines.map(function (outline) {\n    result = result.concat(outline).concat(flaternSingleOutline(outline));\n  });\n  return result;\n};\nvar useOutlines = function (doc) {\n  var isMounted = useIsMounted();\n  var _a = React__namespace.useState([]),\n    outlines = _a[0],\n    setOutlines = _a[1];\n  React__namespace.useEffect(function () {\n    doc.getOutline().then(function (result) {\n      if (isMounted.current && result !== null) {\n        var items = flaternOutlines(result);\n        setOutlines(items);\n      }\n    });\n  }, []);\n  return outlines;\n};\nvar RESIZE_EVENT_OPTIONS = {\n  capture: false,\n  passive: true\n};\nvar ZERO_RECT$1 = {\n  height: 0,\n  width: 0\n};\nvar useWindowResize = function () {\n  var _a = React__namespace.useState(ZERO_RECT$1),\n    windowRect = _a[0],\n    setWindowRect = _a[1];\n  var handleResize = useDebounceCallback(function () {\n    setWindowRect({\n      height: window.innerHeight,\n      width: window.innerWidth\n    });\n  }, 100);\n  useIsomorphicLayoutEffect(function () {\n    window.addEventListener('resize', handleResize, RESIZE_EVENT_OPTIONS);\n    return function () {\n      window.removeEventListener('resize', handleResize, RESIZE_EVENT_OPTIONS);\n    };\n  }, []);\n  return windowRect;\n};\nvar ZERO_RECT = {\n  height: 0,\n  width: 0\n};\nvar useFullScreen = function (_a) {\n  var getCurrentPage = _a.getCurrentPage,\n    getCurrentScrollMode = _a.getCurrentScrollMode,\n    jumpToPage = _a.jumpToPage,\n    targetRef = _a.targetRef;\n  var _b = React__namespace.useState(exports.FullScreenMode.Normal),\n    fullScreenMode = _b[0],\n    setFullScreenMode = _b[1];\n  var windowRect = useWindowResize();\n  var _c = React__namespace.useState(ZERO_RECT),\n    targetRect = _c[0],\n    setTargetRect = _c[1];\n  var windowSizeBeforeFullScreenRef = React__namespace.useRef(ZERO_RECT);\n  var targetPageRef = React__namespace.useRef(getCurrentPage());\n  var fullScreenSizeRef = React__namespace.useRef(ZERO_RECT);\n  var _d = React__namespace.useState(targetRef.current),\n    element = _d[0],\n    setElement = _d[1];\n  var fullScreenElementRef = React__namespace.useRef();\n  useIsomorphicLayoutEffect(function () {\n    if (targetRef.current !== element) {\n      setElement(targetRef.current);\n    }\n  }, []);\n  useIsomorphicLayoutEffect(function () {\n    if (!element) {\n      return;\n    }\n    var io = new ResizeObserver(function (entries) {\n      entries.forEach(function (entry) {\n        var _a = entry.target.getBoundingClientRect(),\n          height = _a.height,\n          width = _a.width;\n        setTargetRect({\n          height: height,\n          width: width\n        });\n      });\n    });\n    io.observe(element);\n    return function () {\n      io.unobserve(element);\n      io.disconnect();\n    };\n  }, [element]);\n  var closeOtherFullScreen = React__namespace.useCallback(function (target) {\n    var currentFullScreenEle = getFullScreenElement();\n    if (currentFullScreenEle && currentFullScreenEle !== target) {\n      setFullScreenMode(exports.FullScreenMode.Normal);\n      return exitFullScreen(currentFullScreenEle);\n    }\n    return Promise.resolve();\n  }, []);\n  var enterFullScreenMode = React__namespace.useCallback(function (target) {\n    if (!target || !isFullScreenEnabled()) {\n      return;\n    }\n    setElement(target);\n    closeOtherFullScreen(target).then(function () {\n      fullScreenElementRef.current = target;\n      setFullScreenMode(exports.FullScreenMode.Entering);\n      requestFullScreen(target);\n    });\n  }, []);\n  var exitFullScreenMode = React__namespace.useCallback(function () {\n    var currentFullScreenEle = getFullScreenElement();\n    if (currentFullScreenEle) {\n      setFullScreenMode(exports.FullScreenMode.Exitting);\n      exitFullScreen(document);\n    }\n  }, []);\n  var handleFullScreenChange = React__namespace.useCallback(function () {\n    if (!element) {\n      return;\n    }\n    var currentFullScreenEle = getFullScreenElement();\n    if (currentFullScreenEle !== element) {\n      setFullScreenMode(exports.FullScreenMode.Exitting);\n    }\n  }, [element]);\n  React__namespace.useEffect(function () {\n    switch (fullScreenMode) {\n      case exports.FullScreenMode.Entering:\n        if (fullScreenElementRef.current) {\n          fullScreenElementRef.current.style.backgroundColor = 'var(--rpv-core__full-screen-target-background-color)';\n        }\n        targetPageRef.current = getCurrentPage();\n        windowSizeBeforeFullScreenRef.current = {\n          height: window.innerHeight,\n          width: window.innerWidth\n        };\n        break;\n      case exports.FullScreenMode.Entered:\n        if (getCurrentScrollMode() === exports.ScrollMode.Page) {\n          jumpToPage(targetPageRef.current).then(function () {\n            setFullScreenMode(exports.FullScreenMode.EnteredCompletely);\n          });\n        } else {\n          setFullScreenMode(exports.FullScreenMode.EnteredCompletely);\n        }\n        break;\n      case exports.FullScreenMode.Exitting:\n        if (fullScreenElementRef.current) {\n          fullScreenElementRef.current.style.backgroundColor = '';\n          fullScreenElementRef.current = null;\n        }\n        targetPageRef.current = getCurrentPage();\n        break;\n      case exports.FullScreenMode.Exited:\n        setFullScreenMode(exports.FullScreenMode.Normal);\n        if (getCurrentScrollMode() === exports.ScrollMode.Page) {\n          jumpToPage(targetPageRef.current);\n        }\n        break;\n    }\n  }, [fullScreenMode]);\n  React__namespace.useEffect(function () {\n    if (fullScreenMode === exports.FullScreenMode.Normal) {\n      return;\n    }\n    if (fullScreenMode === exports.FullScreenMode.Entering && windowRect.height === targetRect.height && windowRect.width === targetRect.width && windowRect.height > 0 && windowRect.width > 0 && (fullScreenSizeRef.current.height === 0 || windowRect.height == fullScreenSizeRef.current.height)) {\n      fullScreenSizeRef.current = {\n        height: window.innerHeight,\n        width: window.innerWidth\n      };\n      setFullScreenMode(exports.FullScreenMode.Entered);\n      return;\n    }\n    if (fullScreenMode === exports.FullScreenMode.Exitting && windowSizeBeforeFullScreenRef.current.height === windowRect.height && windowSizeBeforeFullScreenRef.current.width === windowRect.width && windowRect.height > 0 && windowRect.width > 0) {\n      setFullScreenMode(exports.FullScreenMode.Exited);\n    }\n  }, [fullScreenMode, windowRect, targetRect]);\n  React__namespace.useEffect(function () {\n    addFullScreenChangeListener(handleFullScreenChange);\n    return function () {\n      removeFullScreenChangeListener(handleFullScreenChange);\n    };\n  }, [element]);\n  return {\n    enterFullScreenMode: enterFullScreenMode,\n    exitFullScreenMode: exitFullScreenMode,\n    fullScreenMode: fullScreenMode\n  };\n};\nvar DEFAULT_PAGE_LAYOUT = {\n  buildPageStyles: function () {\n    return {};\n  },\n  transformSize: function (_a) {\n    var size = _a.size;\n    return size;\n  }\n};\nvar ZERO_OFFSET = {\n  left: 0,\n  top: 0\n};\nvar Inner = function (_a) {\n  var currentFile = _a.currentFile,\n    defaultScale = _a.defaultScale,\n    doc = _a.doc,\n    enableSmoothScroll = _a.enableSmoothScroll,\n    initialPage = _a.initialPage,\n    initialRotation = _a.initialRotation,\n    initialScale = _a.initialScale,\n    pageLayout = _a.pageLayout,\n    pageSizes = _a.pageSizes,\n    plugins = _a.plugins,\n    renderPage = _a.renderPage,\n    scrollMode = _a.scrollMode,\n    setRenderRange = _a.setRenderRange,\n    viewMode = _a.viewMode,\n    viewerState = _a.viewerState,\n    onDocumentLoad = _a.onDocumentLoad,\n    onOpenFile = _a.onOpenFile,\n    onPageChange = _a.onPageChange,\n    onRotate = _a.onRotate,\n    onRotatePage = _a.onRotatePage,\n    onZoom = _a.onZoom;\n  var numPages = doc.numPages;\n  var docId = doc.loadingTask.docId;\n  var l10n = React__namespace.useContext(LocalizationContext).l10n;\n  var themeContext = React__namespace.useContext(ThemeContext);\n  var isRtl = themeContext.direction === exports.TextDirection.RightToLeft;\n  var containerRef = React__namespace.useRef();\n  var pagesRef = React__namespace.useRef();\n  var _b = React__namespace.useState(initialPage),\n    currentPage = _b[0],\n    setCurrentPage = _b[1];\n  var mostRecentVisitedRef = React__namespace.useRef(null);\n  var destinationManager = useDestination({\n    getCurrentPage: function () {\n      return stateRef.current.pageIndex;\n    }\n  });\n  var _c = React__namespace.useState(initialRotation),\n    rotation = _c[0],\n    setRotation = _c[1];\n  var previousRotation = usePrevious(rotation);\n  var _d = React__namespace.useState(false),\n    pagesRotationChanged = _d[0],\n    setPagesRotationChanged = _d[1];\n  var _e = React__namespace.useState(new Map()),\n    pagesRotation = _e[0],\n    setPagesRotation = _e[1];\n  var _f = React__namespace.useState(scrollMode),\n    currentScrollMode = _f[0],\n    setCurrentScrollMode = _f[1];\n  var previousScrollMode = usePrevious(currentScrollMode);\n  var _g = React__namespace.useState(viewMode),\n    currentViewMode = _g[0],\n    setCurrentViewMode = _g[1];\n  var previousViewMode = usePrevious(currentViewMode);\n  var outlines = useOutlines(doc);\n  var _h = React__namespace.useState(initialScale),\n    scale = _h[0],\n    setScale = _h[1];\n  var previousScale = usePrevious(scale);\n  var stateRef = React__namespace.useRef(viewerState);\n  var keepSpecialZoomLevelRef = React__namespace.useRef(typeof defaultScale === 'string' ? defaultScale : null);\n  var forceTargetFullScreenRef = React__namespace.useRef(-1);\n  var forceTargetZoomRef = React__namespace.useRef(-1);\n  var forceTargetInitialPageRef = React__namespace.useRef(initialPage);\n  var fullScreen = useFullScreen({\n    getCurrentPage: function () {\n      return stateRef.current.pageIndex;\n    },\n    getCurrentScrollMode: function () {\n      return stateRef.current.scrollMode;\n    },\n    jumpToPage: function (pageIndex) {\n      return jumpToPage(pageIndex);\n    },\n    targetRef: pagesRef\n  });\n  var _j = React__namespace.useState(-1),\n    renderPageIndex = _j[0],\n    setRenderPageIndex = _j[1];\n  var _k = React__namespace.useState(0),\n    renderQueueKey = _k[0],\n    setRenderQueueKey = _k[1];\n  var renderQueue = useRenderQueue({\n    doc: doc\n  });\n  React__namespace.useEffect(function () {\n    return function () {\n      clearPagesCache();\n    };\n  }, [docId]);\n  var layoutBuilder = React__namespace.useMemo(function () {\n    return Object.assign({}, DEFAULT_PAGE_LAYOUT, pageLayout);\n  }, []);\n  var sizes = React__namespace.useMemo(function () {\n    return Array(numPages).fill(0).map(function (_, pageIndex) {\n      var pageSize = [pageSizes[pageIndex].pageHeight, pageSizes[pageIndex].pageWidth];\n      var rect = Math.abs(rotation) % 180 === 0 ? {\n        height: pageSize[0],\n        width: pageSize[1]\n      } : {\n        height: pageSize[1],\n        width: pageSize[0]\n      };\n      var pageRect = {\n        height: rect.height * scale,\n        width: rect.width * scale\n      };\n      return layoutBuilder.transformSize({\n        numPages: numPages,\n        pageIndex: pageIndex,\n        size: pageRect\n      });\n    });\n  }, [rotation, scale]);\n  var virtualizer = useVirtual({\n    enableSmoothScroll: enableSmoothScroll,\n    isRtl: isRtl,\n    numberOfItems: numPages,\n    parentRef: pagesRef,\n    scrollMode: currentScrollMode,\n    setRenderRange: setRenderRange,\n    sizes: sizes,\n    viewMode: currentViewMode\n  });\n  var handlePagesResize = useDebounceCallback(function () {\n    if (!keepSpecialZoomLevelRef.current || stateRef.current.fullScreenMode !== exports.FullScreenMode.Normal || initialPage > 0 && forceTargetInitialPageRef.current === initialPage) {\n      return;\n    }\n    zoom(keepSpecialZoomLevelRef.current);\n  }, 200);\n  useTrackResize({\n    targetRef: pagesRef,\n    onResize: handlePagesResize\n  });\n  var setViewerState = function (viewerState) {\n    var newState = viewerState;\n    plugins.forEach(function (plugin) {\n      if (plugin.onViewerStateChange) {\n        newState = plugin.onViewerStateChange(newState);\n      }\n    });\n    stateRef.current = newState;\n  };\n  var getPagesContainer = function () {\n    return pagesRef.current;\n  };\n  var getViewerState = function () {\n    return stateRef.current;\n  };\n  var handleJumpFromLinkAnnotation = React__namespace.useCallback(function (destination) {\n    destinationManager.markVisitedDestination(destination);\n  }, []);\n  var handleJumpToDestination = React__namespace.useCallback(function (destination) {\n    var pageIndex = destination.pageIndex,\n      bottomOffset = destination.bottomOffset,\n      leftOffset = destination.leftOffset,\n      scaleTo = destination.scaleTo;\n    var pagesContainer = pagesRef.current;\n    var currentState = stateRef.current;\n    if (!pagesContainer || !currentState) {\n      return Promise.resolve();\n    }\n    return new Promise(function (resolve, _) {\n      getPage(doc, pageIndex).then(function (page) {\n        var viewport = page.getViewport({\n          scale: 1\n        });\n        var top = 0;\n        var bottom = (typeof bottomOffset === 'function' ? bottomOffset(viewport.width, viewport.height) : bottomOffset) || 0;\n        var left = (typeof leftOffset === 'function' ? leftOffset(viewport.width, viewport.height) : leftOffset) || 0;\n        var updateScale = currentState.scale;\n        switch (scaleTo) {\n          case exports.SpecialZoomLevel.PageFit:\n            top = 0;\n            left = 0;\n            zoom(exports.SpecialZoomLevel.PageFit);\n            break;\n          case exports.SpecialZoomLevel.PageWidth:\n            updateScale = calculateScale(pagesContainer, pageSizes[pageIndex].pageHeight, pageSizes[pageIndex].pageWidth, exports.SpecialZoomLevel.PageWidth, viewMode, numPages);\n            top = (viewport.height - bottom) * updateScale;\n            left = left * updateScale;\n            zoom(updateScale);\n            break;\n          default:\n            top = (viewport.height - bottom) * updateScale;\n            left = left * updateScale;\n            break;\n        }\n        switch (currentState.scrollMode) {\n          case exports.ScrollMode.Horizontal:\n            virtualizer.scrollToItem(pageIndex, {\n              left: left,\n              top: 0\n            }).then(function () {\n              resolve();\n            });\n            break;\n          case exports.ScrollMode.Vertical:\n          default:\n            virtualizer.scrollToItem(pageIndex, {\n              left: 0,\n              top: top\n            }).then(function () {\n              resolve();\n            });\n            break;\n        }\n      });\n    });\n  }, []);\n  var jumpToDestination = React__namespace.useCallback(function (destination) {\n    destinationManager.markVisitedDestination(destination);\n    return handleJumpToDestination(destination);\n  }, []);\n  var jumpToNextDestination = React__namespace.useCallback(function () {\n    var nextDestination = destinationManager.getNextDestination();\n    return nextDestination ? handleJumpToDestination(nextDestination) : Promise.resolve();\n  }, []);\n  var jumpToPreviousDestination = React__namespace.useCallback(function () {\n    var lastDestination = destinationManager.getPreviousDestination();\n    return lastDestination ? handleJumpToDestination(lastDestination) : Promise.resolve();\n  }, []);\n  var jumpToNextPage = React__namespace.useCallback(function () {\n    return virtualizer.scrollToNextItem(stateRef.current.pageIndex, ZERO_OFFSET);\n  }, []);\n  var jumpToPage = React__namespace.useCallback(function (pageIndex) {\n    return 0 <= pageIndex && pageIndex < numPages ? virtualizer.scrollToItem(pageIndex, ZERO_OFFSET) : Promise.resolve();\n  }, []);\n  var jumpToPreviousPage = React__namespace.useCallback(function () {\n    return virtualizer.scrollToPreviousItem(stateRef.current.pageIndex, ZERO_OFFSET);\n  }, []);\n  var openFile = React__namespace.useCallback(function (file) {\n    if (getFileExt(file.name).toLowerCase() !== 'pdf') {\n      return;\n    }\n    new Promise(function (resolve) {\n      var reader = new FileReader();\n      reader.readAsArrayBuffer(file);\n      reader.onload = function () {\n        var bytes = new Uint8Array(reader.result);\n        resolve(bytes);\n      };\n    }).then(function (data) {\n      onOpenFile(file.name, data);\n    });\n  }, [onOpenFile]);\n  var rotate = React__namespace.useCallback(function (direction) {\n    var degrees = direction === exports.RotateDirection.Backward ? -90 : 90;\n    var currentRotation = stateRef.current.rotation;\n    var updateRotation = currentRotation === 360 || currentRotation === -360 ? degrees : currentRotation + degrees;\n    renderQueue.markNotRendered();\n    setRotation(updateRotation);\n    setViewerState(__assign(__assign({}, stateRef.current), {\n      rotation: updateRotation\n    }));\n    onRotate({\n      direction: direction,\n      doc: doc,\n      rotation: updateRotation\n    });\n  }, []);\n  var rotatePage = React__namespace.useCallback(function (pageIndex, direction) {\n    var degrees = direction === exports.RotateDirection.Backward ? -90 : 90;\n    var rotations = stateRef.current.pagesRotation;\n    var currentPageRotation = rotations.has(pageIndex) ? rotations.get(pageIndex) : initialRotation;\n    var finalRotation = currentPageRotation + degrees;\n    var updateRotations = rotations.set(pageIndex, finalRotation);\n    setPagesRotation(updateRotations);\n    setPagesRotationChanged(function (value) {\n      return !value;\n    });\n    setViewerState(__assign(__assign({}, stateRef.current), {\n      pagesRotation: updateRotations,\n      rotatedPage: pageIndex\n    }));\n    onRotatePage({\n      direction: direction,\n      doc: doc,\n      pageIndex: pageIndex,\n      rotation: finalRotation\n    });\n    renderQueue.markRendering(pageIndex);\n    setRenderPageIndex(pageIndex);\n  }, []);\n  var switchScrollMode = React__namespace.useCallback(function (scrollMode) {\n    setViewerState(__assign(__assign({}, stateRef.current), {\n      scrollMode: scrollMode\n    }));\n    setCurrentScrollMode(scrollMode);\n  }, []);\n  var switchViewMode = React__namespace.useCallback(function (viewMode) {\n    setViewerState(__assign(__assign({}, stateRef.current), {\n      viewMode: viewMode\n    }));\n    setCurrentViewMode(viewMode);\n  }, []);\n  var zoom = React__namespace.useCallback(function (newScale) {\n    var pagesEle = pagesRef.current;\n    var currentPage = stateRef.current.pageIndex;\n    if (currentPage < 0 || currentPage >= numPages) {\n      return;\n    }\n    var currentPageHeight = pageSizes[currentPage].pageHeight;\n    var currentPageWidth = pageSizes[currentPage].pageWidth;\n    var updateScale = pagesEle ? typeof newScale === 'string' ? calculateScale(pagesEle, currentPageHeight, currentPageWidth, newScale, stateRef.current.viewMode, numPages) : newScale : 1;\n    keepSpecialZoomLevelRef.current = typeof newScale === 'string' ? newScale : null;\n    if (updateScale === stateRef.current.scale) {\n      return;\n    }\n    setRenderQueueKey(function (key) {\n      return key + 1;\n    });\n    renderQueue.markNotRendered();\n    setScale(updateScale);\n    onZoom({\n      doc: doc,\n      scale: updateScale\n    });\n    setViewerState(__assign(__assign({}, stateRef.current), {\n      scale: updateScale\n    }));\n  }, []);\n  var enterFullScreenMode = React__namespace.useCallback(function (target) {\n    fullScreen.enterFullScreenMode(target);\n  }, []);\n  var exitFullScreenMode = React__namespace.useCallback(function () {\n    fullScreen.exitFullScreenMode();\n  }, []);\n  React__namespace.useEffect(function () {\n    setViewerState(__assign(__assign({}, stateRef.current), {\n      fullScreenMode: fullScreen.fullScreenMode\n    }));\n  }, [fullScreen.fullScreenMode]);\n  React__namespace.useEffect(function () {\n    var pluginMethods = {\n      enterFullScreenMode: enterFullScreenMode,\n      exitFullScreenMode: exitFullScreenMode,\n      getPagesContainer: getPagesContainer,\n      getViewerState: getViewerState,\n      jumpToDestination: jumpToDestination,\n      jumpToNextDestination: jumpToNextDestination,\n      jumpToPreviousDestination: jumpToPreviousDestination,\n      jumpToNextPage: jumpToNextPage,\n      jumpToPreviousPage: jumpToPreviousPage,\n      jumpToPage: jumpToPage,\n      openFile: openFile,\n      rotate: rotate,\n      rotatePage: rotatePage,\n      setViewerState: setViewerState,\n      switchScrollMode: switchScrollMode,\n      switchViewMode: switchViewMode,\n      zoom: zoom\n    };\n    plugins.forEach(function (plugin) {\n      if (plugin.install) {\n        plugin.install(pluginMethods);\n      }\n    });\n    return function () {\n      plugins.forEach(function (plugin) {\n        if (plugin.uninstall) {\n          plugin.uninstall(pluginMethods);\n        }\n      });\n    };\n  }, [docId]);\n  React__namespace.useEffect(function () {\n    onDocumentLoad({\n      doc: doc,\n      file: currentFile\n    });\n    plugins.forEach(function (plugin) {\n      plugin.onDocumentLoad && plugin.onDocumentLoad({\n        doc: doc,\n        file: currentFile\n      });\n    });\n  }, [docId]);\n  var boundingClientRect = virtualizer.boundingClientRect;\n  useRunOnce(function () {\n    if (initialPage) {\n      jumpToPage(initialPage);\n    }\n  }, boundingClientRect.height > 0 && boundingClientRect.width > 0);\n  useIsomorphicLayoutEffect(function () {\n    var latestPage = stateRef.current.pageIndex;\n    if (latestPage > -1 && previousScrollMode !== currentScrollMode) {\n      virtualizer.scrollToItem(latestPage, ZERO_OFFSET).then(function () {\n        if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely) {\n          if (!enableSmoothScroll) {\n            renderQueue.markNotRendered();\n          }\n          forceTargetFullScreenRef.current = -1;\n        }\n      });\n    }\n  }, [currentScrollMode]);\n  useIsomorphicLayoutEffect(function () {\n    var latestPage = stateRef.current.pageIndex;\n    if (latestPage > -1 && previousRotation !== rotation) {\n      virtualizer.scrollToItem(latestPage, ZERO_OFFSET);\n    }\n  }, [rotation]);\n  useIsomorphicLayoutEffect(function () {\n    if (previousScale != 0 && previousScale != stateRef.current.scale) {\n      virtualizer.zoom(stateRef.current.scale / previousScale, stateRef.current.pageIndex).then(function () {\n        if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely) {\n          forceTargetZoomRef.current = -1;\n        }\n      });\n    }\n  }, [scale]);\n  useIsomorphicLayoutEffect(function () {\n    if (previousViewMode === stateRef.current.viewMode) {\n      return;\n    }\n    var startPage = virtualizer.startPage,\n      endPage = virtualizer.endPage,\n      virtualItems = virtualizer.virtualItems;\n    renderQueue.markNotRendered();\n    renderQueue.setRange(startPage, endPage);\n    var _loop_1 = function (i) {\n      var item = virtualItems.find(function (item) {\n        return item.index === i;\n      });\n      if (item) {\n        renderQueue.setVisibility(i, item.visibility);\n      }\n    };\n    for (var i = startPage; i <= endPage; i++) {\n      _loop_1(i);\n    }\n    renderNextPage();\n  }, [currentViewMode]);\n  useIsomorphicLayoutEffect(function () {\n    var latestPage = stateRef.current.pageIndex;\n    if (latestPage > -1 && previousViewMode !== currentViewMode) {\n      virtualizer.scrollToItem(latestPage, ZERO_OFFSET);\n    }\n  }, [currentViewMode]);\n  useIsomorphicLayoutEffect(function () {\n    var latestPage = stateRef.current.pageIndex;\n    if (latestPage > 0 && latestPage === initialPage && forceTargetInitialPageRef.current === initialPage && keepSpecialZoomLevelRef.current) {\n      forceTargetInitialPageRef.current = -1;\n      zoom(keepSpecialZoomLevelRef.current);\n    }\n  }, [currentPage]);\n  React__namespace.useEffect(function () {\n    var isSmoothScrolling = virtualizer.isSmoothScrolling;\n    if (isSmoothScrolling) {\n      return;\n    }\n    if (mostRecentVisitedRef.current === null || mostRecentVisitedRef.current !== currentPage) {\n      mostRecentVisitedRef.current = currentPage;\n      onPageChange({\n        currentPage: currentPage,\n        doc: doc\n      });\n    }\n  }, [currentPage, virtualizer.isSmoothScrolling]);\n  React__namespace.useEffect(function () {\n    if (fullScreen.fullScreenMode === exports.FullScreenMode.Entering && stateRef.current.scrollMode === exports.ScrollMode.Page) {\n      forceTargetFullScreenRef.current = stateRef.current.pageIndex;\n    }\n    if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely && stateRef.current.scrollMode === exports.ScrollMode.Page && enableSmoothScroll) {\n      forceTargetFullScreenRef.current = -1;\n    }\n    if (fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely && keepSpecialZoomLevelRef.current) {\n      forceTargetZoomRef.current = stateRef.current.pageIndex;\n      zoom(keepSpecialZoomLevelRef.current);\n    }\n  }, [fullScreen.fullScreenMode]);\n  React__namespace.useEffect(function () {\n    if (fullScreen.fullScreenMode === exports.FullScreenMode.Entering || fullScreen.fullScreenMode === exports.FullScreenMode.Exitting || virtualizer.isSmoothScrolling) {\n      return;\n    }\n    var startPage = virtualizer.startPage,\n      endPage = virtualizer.endPage,\n      maxVisbilityIndex = virtualizer.maxVisbilityIndex,\n      virtualItems = virtualizer.virtualItems;\n    var currentPage = maxVisbilityIndex;\n    var isFullScreen = fullScreen.fullScreenMode === exports.FullScreenMode.Entered || fullScreen.fullScreenMode === exports.FullScreenMode.EnteredCompletely;\n    if (isFullScreen && currentPage !== forceTargetFullScreenRef.current && forceTargetFullScreenRef.current > -1) {\n      return;\n    }\n    if (isFullScreen && currentPage !== forceTargetZoomRef.current && forceTargetZoomRef.current > -1) {\n      return;\n    }\n    setCurrentPage(currentPage);\n    setViewerState(__assign(__assign({}, stateRef.current), {\n      pageIndex: currentPage\n    }));\n    renderQueue.setRange(startPage, endPage);\n    var _loop_2 = function (i) {\n      var item = virtualItems.find(function (item) {\n        return item.index === i;\n      });\n      if (item) {\n        renderQueue.setVisibility(i, item.visibility);\n      }\n    };\n    for (var i = startPage; i <= endPage; i++) {\n      _loop_2(i);\n    }\n    renderNextPage();\n  }, [virtualizer.startPage, virtualizer.endPage, virtualizer.isSmoothScrolling, virtualizer.maxVisbilityIndex, fullScreen.fullScreenMode, pagesRotationChanged, rotation, scale]);\n  var handlePageRenderCompleted = React__namespace.useCallback(function (pageIndex) {\n    renderQueue.markRendered(pageIndex);\n    renderNextPage();\n  }, [renderQueueKey]);\n  var renderNextPage = function () {\n    var nextPage = renderQueue.getHighestPriorityPage();\n    if (nextPage > -1 && renderQueue.isInRange(nextPage)) {\n      renderQueue.markRendering(nextPage);\n      setRenderPageIndex(nextPage);\n    }\n  };\n  var executeNamedAction = function (action) {\n    var previousPage = currentPage - 1;\n    var nextPage = currentPage + 1;\n    switch (action) {\n      case 'FirstPage':\n        jumpToPage(0);\n        break;\n      case 'LastPage':\n        jumpToPage(numPages - 1);\n        break;\n      case 'NextPage':\n        nextPage < numPages && jumpToPage(nextPage);\n        break;\n      case 'PrevPage':\n        previousPage >= 0 && jumpToPage(previousPage);\n        break;\n    }\n  };\n  var renderViewer = React__namespace.useCallback(function () {\n    var virtualItems = virtualizer.virtualItems;\n    var chunks = [];\n    switch (currentViewMode) {\n      case exports.ViewMode.DualPage:\n        chunks = chunk(virtualItems, 2);\n        break;\n      case exports.ViewMode.DualPageWithCover:\n        if (virtualItems.length) {\n          chunks = virtualItems[0].index === 0 ? [[virtualItems[0]]].concat(chunk(virtualItems.slice(1), 2)) : chunk(virtualItems, 2);\n        }\n        break;\n      case exports.ViewMode.SinglePage:\n      default:\n        chunks = chunk(virtualItems, 1);\n        break;\n    }\n    var pageLabel = l10n && l10n.core ? l10n.core.pageLabel : 'Page {{pageIndex}}';\n    var slot = {\n      attrs: {\n        className: 'rpv-core__inner-container',\n        'data-testid': 'core__inner-container',\n        ref: containerRef,\n        style: {\n          height: '100%'\n        }\n      },\n      children: React__namespace.createElement(React__namespace.Fragment, null),\n      subSlot: {\n        attrs: {\n          'data-testid': 'core__inner-pages',\n          className: classNames({\n            'rpv-core__inner-pages': true,\n            'rpv-core__inner-pages--horizontal': currentScrollMode === exports.ScrollMode.Horizontal,\n            'rpv-core__inner-pages--rtl': isRtl,\n            'rpv-core__inner-pages--single': currentScrollMode === exports.ScrollMode.Page,\n            'rpv-core__inner-pages--vertical': currentScrollMode === exports.ScrollMode.Vertical,\n            'rpv-core__inner-pages--wrapped': currentScrollMode === exports.ScrollMode.Wrapped\n          }),\n          ref: pagesRef,\n          style: {\n            height: '100%',\n            position: 'relative'\n          }\n        },\n        children: React__namespace.createElement(\"div\", {\n          \"data-testid\": \"core__inner-current-page-\".concat(currentPage),\n          style: Object.assign({\n            '--scale-factor': scale\n          }, virtualizer.getContainerStyles())\n        }, chunks.map(function (items) {\n          return React__namespace.createElement(\"div\", {\n            className: classNames({\n              'rpv-core__inner-page-container': true,\n              'rpv-core__inner-page-container--single': currentScrollMode === exports.ScrollMode.Page\n            }),\n            style: virtualizer.getItemContainerStyles(items[0]),\n            key: \"\".concat(items[0].index, \"-\").concat(currentViewMode)\n          }, items.map(function (item) {\n            var isCover = currentViewMode === exports.ViewMode.DualPageWithCover && (item.index === 0 || numPages % 2 === 0 && item.index === numPages - 1);\n            return React__namespace.createElement(\"div\", {\n              \"aria-label\": pageLabel.replace('{{pageIndex}}', \"\".concat(item.index + 1)),\n              className: classNames({\n                'rpv-core__inner-page': true,\n                'rpv-core__inner-page--dual-even': currentViewMode === exports.ViewMode.DualPage && item.index % 2 === 0,\n                'rpv-core__inner-page--dual-odd': currentViewMode === exports.ViewMode.DualPage && item.index % 2 === 1,\n                'rpv-core__inner-page--dual-cover': isCover,\n                'rpv-core__inner-page--dual-cover-even': currentViewMode === exports.ViewMode.DualPageWithCover && !isCover && item.index % 2 === 0,\n                'rpv-core__inner-page--dual-cover-odd': currentViewMode === exports.ViewMode.DualPageWithCover && !isCover && item.index % 2 === 1,\n                'rpv-core__inner-page--single': currentViewMode === exports.ViewMode.SinglePage && currentScrollMode === exports.ScrollMode.Page\n              }),\n              role: \"region\",\n              key: \"\".concat(item.index, \"-\").concat(currentViewMode),\n              style: Object.assign({}, virtualizer.getItemStyles(item), layoutBuilder.buildPageStyles({\n                numPages: numPages,\n                pageIndex: item.index,\n                scrollMode: currentScrollMode,\n                viewMode: currentViewMode\n              }))\n            }, React__namespace.createElement(PageLayer, {\n              doc: doc,\n              measureRef: item.measureRef,\n              outlines: outlines,\n              pageIndex: item.index,\n              pageRotation: pagesRotation.has(item.index) ? pagesRotation.get(item.index) : 0,\n              pageSize: pageSizes[item.index],\n              plugins: plugins,\n              renderPage: renderPage,\n              renderQueueKey: renderQueueKey,\n              rotation: rotation,\n              scale: scale,\n              shouldRender: renderPageIndex === item.index,\n              viewMode: currentViewMode,\n              onExecuteNamedAction: executeNamedAction,\n              onJumpFromLinkAnnotation: handleJumpFromLinkAnnotation,\n              onJumpToDest: jumpToDestination,\n              onRenderCompleted: handlePageRenderCompleted,\n              onRotatePage: rotatePage\n            }));\n          }));\n        }))\n      }\n    };\n    plugins.forEach(function (plugin) {\n      if (plugin.renderViewer) {\n        slot = plugin.renderViewer({\n          containerRef: containerRef,\n          doc: doc,\n          pagesContainerRef: pagesRef,\n          pagesRotation: pagesRotation,\n          pageSizes: pageSizes,\n          rotation: rotation,\n          slot: slot,\n          themeContext: themeContext,\n          jumpToPage: jumpToPage,\n          openFile: openFile,\n          rotate: rotate,\n          rotatePage: rotatePage,\n          switchScrollMode: switchScrollMode,\n          switchViewMode: switchViewMode,\n          zoom: zoom\n        });\n      }\n    });\n    return slot;\n  }, [plugins, virtualizer]);\n  var renderSlot = React__namespace.useCallback(function (slot) {\n    return React__namespace.createElement(\"div\", __assign({}, slot.attrs, {\n      style: slot.attrs && slot.attrs.style ? slot.attrs.style : {}\n    }), slot.children, slot.subSlot && renderSlot(slot.subSlot));\n  }, []);\n  return renderSlot(renderViewer());\n};\nvar LEVELS = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.3, 1.5, 1.7, 1.9, 2.1, 2.4, 2.7, 3.0, 3.3, 3.7, 4.1, 4.6, 5.1, 5.7, 6.3, 7.0, 7.7, 8.5, 9.4, 10];\nvar decrease = function (currentLevel) {\n  var found = LEVELS.findIndex(function (item) {\n    return item >= currentLevel;\n  });\n  return found === -1 || found === 0 ? currentLevel : LEVELS[found - 1];\n};\nvar RESERVE_HEIGHT = 45;\nvar RESERVE_WIDTH = 45;\nvar PageSizeCalculator = function (_a) {\n  var defaultScale = _a.defaultScale,\n    doc = _a.doc,\n    render = _a.render,\n    scrollMode = _a.scrollMode,\n    viewMode = _a.viewMode;\n  var pagesRef = React__namespace.useRef();\n  var _b = React__namespace.useState({\n      pageSizes: [],\n      scale: 0\n    }),\n    state = _b[0],\n    setState = _b[1];\n  React__namespace.useLayoutEffect(function () {\n    var queryPageSizes = Array(doc.numPages).fill(0).map(function (_, i) {\n      return new Promise(function (resolve, _) {\n        getPage(doc, i).then(function (pdfPage) {\n          var viewport = pdfPage.getViewport({\n            scale: 1\n          });\n          resolve({\n            pageHeight: viewport.height,\n            pageWidth: viewport.width,\n            rotation: viewport.rotation\n          });\n        });\n      });\n    });\n    Promise.all(queryPageSizes).then(function (pageSizes) {\n      var pagesEle = pagesRef.current;\n      if (!pagesEle || pageSizes.length === 0) {\n        return;\n      }\n      var w = pageSizes[0].pageWidth;\n      var h = pageSizes[0].pageHeight;\n      var parentEle = pagesEle.parentElement;\n      var scaleWidth = (parentEle.clientWidth - RESERVE_WIDTH) / w;\n      var scaleHeight = (parentEle.clientHeight - RESERVE_HEIGHT) / h;\n      var scaled = scaleWidth;\n      switch (scrollMode) {\n        case exports.ScrollMode.Horizontal:\n          scaled = Math.min(scaleWidth, scaleHeight);\n          break;\n        case exports.ScrollMode.Vertical:\n        default:\n          scaled = scaleWidth;\n          break;\n      }\n      var scale = defaultScale ? typeof defaultScale === 'string' ? calculateScale(parentEle, h, w, defaultScale, viewMode, doc.numPages) : defaultScale : decrease(scaled);\n      setState({\n        pageSizes: pageSizes,\n        scale: scale\n      });\n    });\n  }, [doc.loadingTask.docId]);\n  return state.pageSizes.length === 0 || state.scale === 0 ? React__namespace.createElement(\"div\", {\n    className: \"rpv-core__page-size-calculator\",\n    \"data-testid\": \"core__page-size-calculating\",\n    ref: pagesRef\n  }, React__namespace.createElement(Spinner, null)) : render(state.pageSizes, state.scale);\n};\nvar LoadingStatus = function () {\n  function LoadingStatus() {}\n  return LoadingStatus;\n}();\nvar AskForPasswordState = function (_super) {\n  __extends(AskForPasswordState, _super);\n  function AskForPasswordState(verifyPassword, passwordStatus) {\n    var _this = _super.call(this) || this;\n    _this.verifyPassword = verifyPassword;\n    _this.passwordStatus = passwordStatus;\n    return _this;\n  }\n  return AskForPasswordState;\n}(LoadingStatus);\nvar AskingPassword = function (_a) {\n  var passwordStatus = _a.passwordStatus,\n    renderProtectedView = _a.renderProtectedView,\n    verifyPassword = _a.verifyPassword,\n    onDocumentAskPassword = _a.onDocumentAskPassword;\n  var l10n = React__namespace.useContext(LocalizationContext).l10n;\n  var _b = React__namespace.useState(''),\n    password = _b[0],\n    setPassword = _b[1];\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  var submit = function () {\n    return verifyPassword(password);\n  };\n  var handleKeyDown = function (e) {\n    if (e.key === 'Enter') {\n      submit();\n    }\n  };\n  React__namespace.useEffect(function () {\n    if (onDocumentAskPassword) {\n      onDocumentAskPassword({\n        verifyPassword: verifyPassword\n      });\n    }\n  }, []);\n  if (renderProtectedView) {\n    return renderProtectedView({\n      passwordStatus: passwordStatus,\n      verifyPassword: verifyPassword\n    });\n  }\n  return React__namespace.createElement(\"div\", {\n    className: \"rpv-core__asking-password-wrapper\"\n  }, React__namespace.createElement(\"div\", {\n    className: classNames({\n      'rpv-core__asking-password': true,\n      'rpv-core__asking-password--rtl': isRtl\n    })\n  }, React__namespace.createElement(\"div\", {\n    className: \"rpv-core__asking-password-message\"\n  }, passwordStatus === exports.PasswordStatus.RequiredPassword && l10n.core.askingPassword.requirePasswordToOpen, passwordStatus === exports.PasswordStatus.WrongPassword && l10n.core.wrongPassword.tryAgain), React__namespace.createElement(\"div\", {\n    className: \"rpv-core__asking-password-body\"\n  }, React__namespace.createElement(\"div\", {\n    className: classNames({\n      'rpv-core__asking-password-input': true,\n      'rpv-core__asking-password-input--ltr': !isRtl,\n      'rpv-core__asking-password-input--rtl': isRtl\n    })\n  }, React__namespace.createElement(TextBox, {\n    testId: \"core__asking-password-input\",\n    type: \"password\",\n    value: password,\n    onChange: setPassword,\n    onKeyDown: handleKeyDown\n  })), React__namespace.createElement(PrimaryButton, {\n    onClick: submit\n  }, l10n.core.askingPassword.submit))));\n};\nvar CompletedState = function (_super) {\n  __extends(CompletedState, _super);\n  function CompletedState(doc) {\n    var _this = _super.call(this) || this;\n    _this.doc = doc;\n    return _this;\n  }\n  return CompletedState;\n}(LoadingStatus);\nvar FailureState = function (_super) {\n  __extends(FailureState, _super);\n  function FailureState(error) {\n    var _this = _super.call(this) || this;\n    _this.error = error;\n    return _this;\n  }\n  return FailureState;\n}(LoadingStatus);\nvar LoadingState = function (_super) {\n  __extends(LoadingState, _super);\n  function LoadingState(percentages) {\n    var _this = _super.call(this) || this;\n    _this.percentages = percentages;\n    return _this;\n  }\n  return LoadingState;\n}(LoadingStatus);\nvar DocumentLoader = function (_a) {\n  var characterMap = _a.characterMap,\n    file = _a.file,\n    httpHeaders = _a.httpHeaders,\n    render = _a.render,\n    renderError = _a.renderError,\n    renderLoader = _a.renderLoader,\n    renderProtectedView = _a.renderProtectedView,\n    transformGetDocumentParams = _a.transformGetDocumentParams,\n    withCredentials = _a.withCredentials,\n    onDocumentAskPassword = _a.onDocumentAskPassword;\n  var direction = React__namespace.useContext(ThemeContext).direction;\n  var isRtl = direction === exports.TextDirection.RightToLeft;\n  var _b = React__namespace.useState(new LoadingState(0)),\n    status = _b[0],\n    setStatus = _b[1];\n  var docRef = React__namespace.useRef('');\n  var isMounted = useIsMounted();\n  React__namespace.useEffect(function () {\n    docRef.current = '';\n    setStatus(new LoadingState(0));\n    var worker = new PdfJsApi__namespace.PDFWorker({\n      name: \"PDFWorker_\".concat(Date.now())\n    });\n    var params = Object.assign({\n      httpHeaders: httpHeaders,\n      withCredentials: withCredentials,\n      worker: worker\n    }, 'string' === typeof file ? {\n      url: file\n    } : {\n      data: file\n    }, characterMap ? {\n      cMapUrl: characterMap.url,\n      cMapPacked: characterMap.isCompressed\n    } : {});\n    var transformParams = transformGetDocumentParams ? transformGetDocumentParams(params) : params;\n    var loadingTask = PdfJsApi__namespace.getDocument(transformParams);\n    loadingTask.onPassword = function (verifyPassword, reason) {\n      switch (reason) {\n        case PdfJsApi__namespace.PasswordResponses.NEED_PASSWORD:\n          isMounted.current && setStatus(new AskForPasswordState(verifyPassword, exports.PasswordStatus.RequiredPassword));\n          break;\n        case PdfJsApi__namespace.PasswordResponses.INCORRECT_PASSWORD:\n          isMounted.current && setStatus(new AskForPasswordState(verifyPassword, exports.PasswordStatus.WrongPassword));\n          break;\n      }\n    };\n    loadingTask.onProgress = function (progress) {\n      var loaded = progress.total > 0 ? Math.min(100, 100 * progress.loaded / progress.total) : 100;\n      if (isMounted.current && docRef.current === '') {\n        setStatus(new LoadingState(loaded));\n      }\n    };\n    loadingTask.promise.then(function (doc) {\n      docRef.current = doc.loadingTask.docId;\n      isMounted.current && setStatus(new CompletedState(doc));\n    }, function (err) {\n      return isMounted.current && !worker.destroyed && setStatus(new FailureState({\n        message: err.message || 'Cannot load document',\n        name: err.name\n      }));\n    });\n    return function () {\n      loadingTask.destroy();\n      worker.destroy();\n    };\n  }, [file]);\n  if (status instanceof AskForPasswordState) {\n    return React__namespace.createElement(AskingPassword, {\n      passwordStatus: status.passwordStatus,\n      renderProtectedView: renderProtectedView,\n      verifyPassword: status.verifyPassword,\n      onDocumentAskPassword: onDocumentAskPassword\n    });\n  }\n  if (status instanceof CompletedState) {\n    return render(status.doc);\n  }\n  if (status instanceof FailureState) {\n    return renderError ? renderError(status.error) : React__namespace.createElement(\"div\", {\n      className: classNames({\n        'rpv-core__doc-error': true,\n        'rpv-core__doc-error--rtl': isRtl\n      })\n    }, React__namespace.createElement(\"div\", {\n      className: \"rpv-core__doc-error-text\"\n    }, status.error.message));\n  }\n  return React__namespace.createElement(\"div\", {\n    \"data-testid\": \"core__doc-loading\",\n    className: classNames({\n      'rpv-core__doc-loading': true,\n      'rpv-core__doc-loading--rtl': isRtl\n    })\n  }, renderLoader ? renderLoader(status.percentages) : React__namespace.createElement(Spinner, null));\n};\nvar isDarkMode = function () {\n  return typeof window !== 'undefined' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n};\nvar withTheme = function (theme, onSwitchTheme) {\n  var initialTheme = React__namespace.useMemo(function () {\n    return theme === 'auto' ? isDarkMode() ? 'dark' : 'light' : theme;\n  }, []);\n  var _a = React__namespace.useState(initialTheme),\n    currentTheme = _a[0],\n    setCurrentTheme = _a[1];\n  var prevTheme = usePrevious(currentTheme);\n  React__namespace.useEffect(function () {\n    if (theme !== 'auto') {\n      return;\n    }\n    var media = window.matchMedia('(prefers-color-scheme: dark)');\n    var handler = function (e) {\n      setCurrentTheme(e.matches ? 'dark' : 'light');\n    };\n    media.addEventListener('change', handler);\n    return function () {\n      return media.removeEventListener('change', handler);\n    };\n  }, []);\n  React__namespace.useEffect(function () {\n    if (currentTheme !== prevTheme && onSwitchTheme) {\n      onSwitchTheme(currentTheme);\n    }\n  }, [currentTheme]);\n  React__namespace.useEffect(function () {\n    if (theme !== currentTheme) {\n      setCurrentTheme(theme);\n    }\n  }, [theme]);\n  return {\n    currentTheme: currentTheme,\n    setCurrentTheme: setCurrentTheme\n  };\n};\nvar isSameUrl = function (a, b) {\n  var typeA = typeof a;\n  var typeB = typeof b;\n  if (typeA === 'string' && typeB === 'string' && a === b) {\n    return true;\n  }\n  if (typeA === 'object' && typeB === 'object') {\n    return a.length === b.length && a.every(function (v, i) {\n      return v === b[i];\n    });\n  }\n  return false;\n};\nvar NUM_OVERSCAN_PAGES = 3;\nvar DEFAULT_RENDER_RANGE = function (visiblePagesRange) {\n  return {\n    startPage: visiblePagesRange.startPage - NUM_OVERSCAN_PAGES,\n    endPage: visiblePagesRange.endPage + NUM_OVERSCAN_PAGES\n  };\n};\nvar Viewer = function (_a) {\n  var characterMap = _a.characterMap,\n    defaultScale = _a.defaultScale,\n    _b = _a.enableSmoothScroll,\n    enableSmoothScroll = _b === void 0 ? true : _b,\n    fileUrl = _a.fileUrl,\n    _c = _a.httpHeaders,\n    httpHeaders = _c === void 0 ? {} : _c,\n    _d = _a.initialPage,\n    initialPage = _d === void 0 ? 0 : _d,\n    pageLayout = _a.pageLayout,\n    _e = _a.initialRotation,\n    initialRotation = _e === void 0 ? 0 : _e,\n    localization = _a.localization,\n    _f = _a.plugins,\n    plugins = _f === void 0 ? [] : _f,\n    renderError = _a.renderError,\n    renderLoader = _a.renderLoader,\n    renderPage = _a.renderPage,\n    renderProtectedView = _a.renderProtectedView,\n    _g = _a.scrollMode,\n    scrollMode = _g === void 0 ? exports.ScrollMode.Vertical : _g,\n    _h = _a.setRenderRange,\n    setRenderRange = _h === void 0 ? DEFAULT_RENDER_RANGE : _h,\n    transformGetDocumentParams = _a.transformGetDocumentParams,\n    _j = _a.theme,\n    theme = _j === void 0 ? {\n      direction: exports.TextDirection.LeftToRight,\n      theme: 'light'\n    } : _j,\n    _k = _a.viewMode,\n    viewMode = _k === void 0 ? exports.ViewMode.SinglePage : _k,\n    _l = _a.withCredentials,\n    withCredentials = _l === void 0 ? false : _l,\n    onDocumentAskPassword = _a.onDocumentAskPassword,\n    _m = _a.onDocumentLoad,\n    onDocumentLoad = _m === void 0 ? function () {} : _m,\n    _o = _a.onPageChange,\n    onPageChange = _o === void 0 ? function () {} : _o,\n    _p = _a.onRotate,\n    onRotate = _p === void 0 ? function () {} : _p,\n    _q = _a.onRotatePage,\n    onRotatePage = _q === void 0 ? function () {} : _q,\n    _r = _a.onSwitchTheme,\n    onSwitchTheme = _r === void 0 ? function () {} : _r,\n    _s = _a.onZoom,\n    onZoom = _s === void 0 ? function () {} : _s;\n  var _t = React__namespace.useState({\n      data: fileUrl,\n      name: typeof fileUrl === 'string' ? fileUrl : '',\n      shouldLoad: false\n    }),\n    file = _t[0],\n    setFile = _t[1];\n  var openFile = function (fileName, data) {\n    setFile({\n      data: data,\n      name: fileName,\n      shouldLoad: true\n    });\n  };\n  var _u = React__namespace.useState(false),\n    visible = _u[0],\n    setVisible = _u[1];\n  var prevFile = usePrevious(file);\n  React__namespace.useEffect(function () {\n    if (!isSameUrl(prevFile.data, fileUrl)) {\n      setFile({\n        data: fileUrl,\n        name: typeof fileUrl === 'string' ? fileUrl : '',\n        shouldLoad: visible\n      });\n    }\n  }, [fileUrl, visible]);\n  var visibilityChanged = function (params) {\n    setVisible(params.isVisible);\n    if (params.isVisible) {\n      setFile(function (currentFile) {\n        return Object.assign({}, currentFile, {\n          shouldLoad: true\n        });\n      });\n    }\n  };\n  var containerRef = useIntersectionObserver({\n    onVisibilityChanged: visibilityChanged\n  });\n  var themeProps = typeof theme === 'string' ? {\n    direction: exports.TextDirection.LeftToRight,\n    theme: theme\n  } : theme;\n  var _v = React__namespace.useState(localization || DefaultLocalization),\n    l10n = _v[0],\n    setL10n = _v[1];\n  var localizationContext = {\n    l10n: l10n,\n    setL10n: setL10n\n  };\n  var themeContext = Object.assign({}, {\n    direction: themeProps.direction\n  }, withTheme(themeProps.theme || 'light', onSwitchTheme));\n  React__namespace.useEffect(function () {\n    if (localization) {\n      setL10n(localization);\n    }\n  }, [localization]);\n  return React__namespace.createElement(LocalizationContext.Provider, {\n    value: localizationContext\n  }, React__namespace.createElement(ThemeContext.Provider, {\n    value: themeContext\n  }, React__namespace.createElement(\"div\", {\n    ref: containerRef,\n    className: \"rpv-core__viewer rpv-core__viewer--\".concat(themeContext.currentTheme),\n    \"data-testid\": \"core__viewer\",\n    style: {\n      height: '100%',\n      width: '100%'\n    }\n  }, file.shouldLoad && React__namespace.createElement(DocumentLoader, {\n    characterMap: characterMap,\n    file: file.data,\n    httpHeaders: httpHeaders,\n    render: function (doc) {\n      return React__namespace.createElement(PageSizeCalculator, {\n        defaultScale: defaultScale,\n        doc: doc,\n        render: function (pageSizes, initialScale) {\n          return React__namespace.createElement(Inner, {\n            currentFile: {\n              data: file.data,\n              name: file.name\n            },\n            defaultScale: defaultScale,\n            doc: doc,\n            enableSmoothScroll: enableSmoothScroll,\n            initialPage: initialPage,\n            initialRotation: initialRotation,\n            initialScale: initialScale,\n            pageLayout: pageLayout,\n            pageSizes: pageSizes,\n            plugins: plugins,\n            renderPage: renderPage,\n            scrollMode: scrollMode,\n            setRenderRange: setRenderRange,\n            viewMode: viewMode,\n            viewerState: {\n              file: file,\n              fullScreenMode: exports.FullScreenMode.Normal,\n              pageIndex: -1,\n              pageHeight: pageSizes[0].pageHeight,\n              pageWidth: pageSizes[0].pageWidth,\n              pagesRotation: new Map(),\n              rotation: initialRotation,\n              scale: initialScale,\n              scrollMode: scrollMode,\n              viewMode: viewMode\n            },\n            onDocumentLoad: onDocumentLoad,\n            onOpenFile: openFile,\n            onPageChange: onPageChange,\n            onRotate: onRotate,\n            onRotatePage: onRotatePage,\n            onZoom: onZoom\n          });\n        },\n        scrollMode: scrollMode,\n        viewMode: viewMode\n      });\n    },\n    renderError: renderError,\n    renderLoader: renderLoader,\n    renderProtectedView: renderProtectedView,\n    transformGetDocumentParams: transformGetDocumentParams,\n    withCredentials: withCredentials,\n    onDocumentAskPassword: onDocumentAskPassword\n  }))));\n};\nvar Worker = function (_a) {\n  var children = _a.children,\n    workerUrl = _a.workerUrl;\n  PdfJsApi__namespace.GlobalWorkerOptions.workerSrc = workerUrl;\n  return React__namespace.createElement(React__namespace.Fragment, null, children);\n};\nexports.Button = Button;\nexports.Icon = Icon;\nexports.LazyRender = LazyRender;\nexports.LocalizationContext = LocalizationContext;\nexports.Menu = Menu;\nexports.MenuDivider = MenuDivider;\nexports.MenuItem = MenuItem;\nexports.MinimalButton = MinimalButton;\nexports.Modal = Modal;\nexports.Popover = Popover;\nexports.PrimaryButton = PrimaryButton;\nexports.ProgressBar = ProgressBar;\nexports.Separator = Separator;\nexports.Spinner = Spinner;\nexports.Splitter = Splitter;\nexports.TextBox = TextBox;\nexports.ThemeContext = ThemeContext;\nexports.Tooltip = Tooltip;\nexports.Viewer = Viewer;\nexports.Worker = Worker;\nexports.chunk = chunk;\nexports.classNames = classNames;\nexports.createStore = createStore;\nexports.getDestination = getDestination;\nexports.getPage = getPage;\nexports.isFullScreenEnabled = isFullScreenEnabled;\nexports.isMac = isMac;\nexports.useDebounceCallback = useDebounceCallback;\nexports.useIntersectionObserver = useIntersectionObserver;\nexports.useIsMounted = useIsMounted;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.usePrevious = usePrevious;\nexports.useRenderQueue = useRenderQueue;","map":null,"metadata":{},"sourceType":"script"}